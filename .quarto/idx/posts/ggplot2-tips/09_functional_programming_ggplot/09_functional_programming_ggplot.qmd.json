{"title":"How to use functional programming for ggplot","markdown":{"yaml":{"title":"How to use functional programming for ggplot","date":"2022-03-25","categories":["Visualization","Functional Programming"],"description":"Functional programming is a mighty sword. Today, we use it to avoid tedious repetitions when things go wrong in ggplot.","execute":{"message":false,"warning":false,"collapse":false},"editor_options":{"chunk_output_type":"console"}},"headingText":"| echo: false","containsRefs":false,"markdown":"\n\n```{r}\n#| results: 'hide'\nrenv::use(lockfile = \"renv.lock\")\n```\n\n```{r, echo = F}\nSys.setenv(lang = 'EN')\n```\n\n\nA couple of weeks back, I recreated an info graphic with `ggplot2`.\nThe result and the whole story is embedded in this thread on Twitter:\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">The fun thing about getting better at <a href=\"https://twitter.com/hashtag/ggplot2?src=hash&amp;ref_src=twsrc%5Etfw\">#ggplot2</a> is that you begin to mimick other <a href=\"https://twitter.com/hashtag/dataviz?src=hash&amp;ref_src=twsrc%5Etfw\">#dataviz</a>.<br><br>Here is a practice <a href=\"https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw\">#rstats</a> info graphic I created after seeing a similar infographic from <a href=\"https://twitter.com/EatSmarter_de?ref_src=twsrc%5Etfw\">@EatSmarter_de</a> <br><br>Original graphic, making of, comments and some ressources below ‚¨áÔ∏èüßµ <a href=\"https://t.co/FslScy9sc7\">pic.twitter.com/FslScy9sc7</a></p>&mdash; Albert Rapp (@rappa753) <a href=\"https://twitter.com/rappa753/status/1500213701370171392?ref_src=twsrc%5Etfw\">March 5, 2022</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script> \n\nAside from the embarrasing typo in \"What you should **know**...\", I picked up a useful technique for what do when I want aesthetics to vary within a geom.\nSounds complicated? \nLet's take a look at a couple of examples.\n\n## How do I manually set aesthetics with aes() and scale_*_identity()?\n\nThis one is the easy case when all geoms behave properly.\n\n```{r, message = F, warning = F}\nlibrary(tidyverse)\ntheme_set(theme_minimal())\ntib <- tribble(\n  ~x, ~xend, ~y, ~yend, ~size_col,\n  0, 1, 0, 1, 1,\n  1, 2, 1, 1, 5\n)\n\ntib %>% \n  ggplot(aes(x = x, xend = xend, y = y, yend = yend, size = size_col)) +\n  geom_segment(col = 'dodgerblue4') +\n  scale_size_identity()\n```\n\nNotice that \n\n* the sizes were determined in the `size_col` column of `tib`.\n* sizes were mapped to the aesthethic via `aes()`.\n* the `scale_size_identity()` layer makes sure that the sizes are not assigned by ggplot but taken as given \n(identity scale layers are available for other aesthetics as well).\n\n## How do I manually set aesthetics without aes()?\n\nThe last example used `aes()` to access `size_col` from `tib`.\nHowever, we then had to make sure that ggplot does not assign sizes based on unique values in `size_col`.\nInstead, sizes were supposed to be taken as is.\nThis was the job of `scale_size_identity()`.\nLet's make it work without it.\n\n```{r, eval = F}\ntib %>% \n  ggplot(aes(x = x, xend = xend, y = y, yend = yend)) +\n  geom_segment(col = 'dodgerblue4', size = tib$size_col) \n```\n\nThis will generate the exact same plot as before (which is why I suppressed the output).\nIn this case, we mapped the sizes manually by assigning a vector of sizes to the `size`\naesthetic within `geom_segment()` but **outside** `aes()`.\n\nOf course, now we cannot simply write `size = size_col` because `geom_segment()` won't know that variable.\nBefore, `aes()` let ggplot know that we mean `size_col` from the data set `tib`.\nNow, we have to pass the vector by accessing it from `tib` ourself through `tib$size_col`.\n\n## How do I manually set aesthethics when the previous approaches do not work?\n\nFinally, let's switch from `geom_segment()` to `geom_curve()`.\n\n```{r}\ntib %>% \n  ggplot(aes(x = x, xend = xend, y = y, yend = yend)) +\n  geom_curve(col = 'dodgerblue4', size = tib$size_col, curvature = 0.6) \n```\n\nThis changes our straight lines from before to curved lines.\nWhat's more, I can control how strong the curvature is supposed to be via `curvature`.\nBut as it is right now, both of our differently-sized curves have the same level of curvature.\n\nMaybe, this ought to be different.\nMaybe, not all curves are made the same.\nMaybe, our visualization should reflect the diversity of all the curves out there in this gigantic world we inhabit.\nAll curves are beautiful!\n\nLet's make this happen as we did before.\n\n```{r, error=T, results='hide'}\ntib %>% \n  ggplot(aes(x = x, xend = xend, y = y, yend = yend)) +\n  geom_curve(\n    col = 'dodgerblue4', \n    size = tib$size_col, \n    curvature = c(-0.3, 0.6) # two curves, two different curvatures\n  ) \n```\n\nOh no! \nIt seems as if `geom_curve()` expects the argument of `curvature` to be a single number.\nMaybe `aes()` then?\n\n```{r}\ntib %>% \n  ggplot(aes(x = x, xend = xend, y = y, yend = yend)) +\n  geom_curve(\n    aes(curvature = c(-0.3, 0.6)),\n    col = 'dodgerblue4', \n    size = tib$size_col \n  ) \n```\n\nWell, at least this time we can see curves.\nUnfortunately, the warning let's us know that `curvature` is an unknown aesthetic which will be ignored.\nAs you can see, this results in the same curvature for both curves again.\n\nSo, it looks like we can only hope to set each curvature separately.\n```{r}\nggplot(mapping = aes(x = x, xend = xend, y = y, yend = yend)) +\n  geom_curve(\n    data = slice(tib, 1), # first row of tib\n    col = 'dodgerblue4', \n    size = tib$size_col[1], # one size only\n    curvature = -0.3\n  ) +\n  geom_curve(\n    data = slice(tib, 2), # second row of tib\n    col = 'dodgerblue4', \n    size = tib$size_col[2], # other size\n    curvature = 0.6\n  ) \n```\n\nAlright, this time we got what we wanted.\nThat's something at least.\nHonestly, our \"solution\" is not scalable though.\nWhat if we want to draw hundreds of curves?\n\nIn fact, this is what slowed me down when I created the info graphic that started this blog post.\nThe text boxes were not vectorized so I would have to place each text box manually.\nThat's a lot of text boxes and I was having none of that.\n\nSo, here is where functional programming stepped in.\nLet's recreate what I did based on our curve example.\nFirst, we extend `tib` with another curvature column.\n\n```{r}\ntib <- tib %>% mutate(curvature = c(-0.3, 0.6))\ntib\n```\n\nThen, we use `pmap()` to create a **list of curve layers**.\nIf you have not used any functional programming before, checkout my [YARDS lecture notes](https://yards.albert-rapp.de/lm-with-lists.html) on that topic.\nBasically, what we will do is to apply the `geom_curve()` function to each row of the `tib` data.\nVia `~` (in front of the function) and `..1`, `..2`, etc. we can then say where to stick in the values from each of `tib`'s columns.\n\n```{r}\ncurve_layers <- tib %>% \n  pmap(~geom_curve(\n    mapping = aes(x = ..1, xend = ..2, y = ..3, yend = ..4),\n    size = ..5,\n    curvature = ..6,\n    col = 'dodgerblue4'\n  ))\ncurve_layers\n```\n\nHere, we have set the first column of `tib` (`x`) to the `x`-aesthetic within aes.\nThen, we proceeded similarly for all other columns.\nThis resulted in a list of curve layers.\n\nThese are useless without a `ggplot()` head.\nSo, let's complete the plot.\n\n```{r}\nggplot() +\n  curve_layers \n```\n\nDamn, these are some nice functionally created curves.\nNow, let's put our new technique to a test. \nCan it handle arbitrarily many curves?\n\n```{r}\nn_curves <- 50\ncurve_layers <- tibble(\n    x = runif(n_curves),\n    xend = runif(n_curves),\n    y = runif(n_curves),\n    yend = runif(n_curves),\n    size = runif(n_curves, 0, 2), \n    curvature = runif(n_curves, -1, 1)\n  ) %>% \n  pmap(~geom_curve(\n    mapping = aes(x = ..1, xend = ..2, y = ..3, yend = ..4),\n    size = ..5,\n    curvature = ..6,\n    col = 'dodgerblue4'\n  ))\nggplot() + curve_layers\n```\n\nCongratulations!\nWe have successfully created drawings of a toddler.\nAnd the even better news is that we can draw as many curves as we want.\n\nSurprisingly, before I started this blog post, I was not aware that you can simply add lists to `ggplot()` and it works.\nAs you will see in the Twitter thread on top of this post, I initially thought that one had to combine the list with more functional programming like so.\n\n```{r}\ncombine_gg_elements <- function(...) {\n  Reduce(`+`, list(...))\n}\ncombine_gg_elements(ggplot(), curve_layers)\n```\n\nThis was something I picked up from Hadley Wickham's [ggplot2 book](https://ggplot2-book.org/programming.html#functional-programming) but it seems that we don't need that anymore (the combine function, the book is still a great ressource). \nBut I leave this here for completeness' sake.\nOnce again, writing a blog post has taught me stuff I thought I already knew.\nIf you want to watch me learn more stuff or want to learn more ggplot things yourself, feel free to subscribe to my [RSS feed](https://albert-rapp.de/blog.xml) or follow me on [Twitter](https://twitter.com/rappa753).\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["code-filename","lightbox"],"toc":true,"toc-depth":3,"include-after-body":["../../../footer.html"],"output-file":"09_functional_programming_ggplot.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.35","lightbox":"auto","editor":"source","theme":{"light":"../../../theme.scss"},"title-block-banner":false,"author":"Albert Rapp","page-layout":"article","comments":{"utterances":{"repo":"AlbertRapp/blogComments"}},"title":"How to use functional programming for ggplot","date":"2022-03-25","categories":["Visualization","Functional Programming"],"description":"Functional programming is a mighty sword. Today, we use it to avoid tedious repetitions when things go wrong in ggplot.","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}}}
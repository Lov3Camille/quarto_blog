{"title":"Animating kernel density estimators","markdown":{"yaml":{"title":"Animating kernel density estimators","date":"2021-07-14","categories":[],"description":"For my first post I create an animation using the animate package.","execute":{"message":false,"warning":false,"collapse":false},"editor_options":{"chunk_output_type":"console"}},"headingText":"| echo: false","containsRefs":false,"markdown":"\n\n```{r}\n#| results: 'hide'\nrenv::use(lockfile = \"renv_snap.lock\")\n```\n\n\nFor my first post on this blog I decided to create an animation using the [`animation`](https://yihui.org/animation/) package.\nTo give this animation some purpose let me demonstrate how kernel density estimators work with the help of an animation.\n\nIn general, kernel density estimators are, as is kind of obvious by the name, used to estimate the underlying density of a random sample.\nFor instance, imagine that we have a sample drawn from an some unknown distribution.\n\n```{r}\nn <- 100\nsample <- rexp(n)\n```\n\nThen, assuming that we do not actually know that the current sample was drawn from an exponential distribution, we might want to estimate the density and see if the estimate fits to some well-known parametric family of distributions.\nWith the help of `ggplot()` and `geom_density()` this is straightforward.\n\n```{r, message = F, warning=F}\nlibrary(tidyverse)\nggplot() +\n  geom_density(aes(x = sample))\n```\n\nThe underlying procedure to generate the plot it to use a kernel density estimator $\\hat{f}_h$ in order to estimate the true underlying density $f$ by using the formula\n\n$$\n\\hat{f}_h(x) = \\frac{1}{nh} \\sum_{k = 1}^{n} K\\Big(\\frac{x - x_k}{h}\\Big)\n$$\n\nfor all $x \\in \\mathbb{R}$ where $n$ is the sample lengh and $h > 0$ is a smoothing parameter that needs to be chosen and $K$ is a \"suitable\" function. \nUsually, this parameter $h$ is called **bandwidth** and $K$ is called a **kernel function** which is often to be the density of a probability distribution.\n\n## The Bandwidth\n\nIn `geom_density()`, the default kernel function is the Gaussian density and the bandwidth can be tweaked through the `bw` argument.\n\n```{r}\nh <- 1\nggplot() +\n  geom_density(aes(x = sample), bw = h) +\n  annotate(\n    \"label\", \n    x = 0.5, \n    y = 0.1, \n    label = glue::glue(\"bw = {h}\")\n  )\n```\n\nOf course, I could now create multiple plots and change the value if `h` each time to demonstrate the effect of the bandwidth but the point of this post was to create an animation.\nSo let's do that instead.\n\nNevertheless, to create an animation, we need to be able to create multiple plots.\nTherefore, let us use the previous code and wrap a function depending on `h` around that.\nThis function will be our plot generator depending on the bandwidth.\n\n```{r}\nplot_gen <- function(h) {\n  g <- ggplot() +\n    geom_density(aes(x = sample), bw = h) +\n    annotate(\n      \"label\", \n      x = 0.5, \n      y = 0.1, \n      label = glue::glue(\"bw = {h}\")\n    )\n  print(g) \n  # For the animation we need this to be printed\n}\n```\n\nNow that we have that, define a function that creates **all** the plots we want to see in our animation, i.e. we create the animation frame by frame.\nThis function can then be passed to `saveGIF()` from the `animation` package which then renders the animation for us.\nCreating a gif in R is as simple as that.\n\n```{r}\nall_the_plots <- function() {\n  map(seq(0.05, 0.5, 0.05), plot_gen)\n}\nlibrary(animation)\nsaveGIF(all_the_plots())\n```\n\n```{r, echo = F, message = F, warning = F}\nknitr::include_graphics(\"animation.gif\")\n```\n\nAs you can see, the bandwidth really is a smoothing parameter.\nOf course, too much smoothing may not yield great results so the parameter needs to be chosen with care but let us not worry about this in this blog post.\n\n## The Actual Estimation Procedure\n\nLet us create another animation to visualize how kernel density estimation works on a more basic level, i.e. .\nIn order to do so, notice that if the kernel $K$ is a continuous density function of a random variable $X$ (e.g. a Gaussian random variable), then the density function of the random variable $(X + x_0)h$ where $x_0 \\in \\mathbb{R}$ and $h > 0$ is given by $K((X - x_0)/h)/h.$\n\nConsequently, in the case of standard Gaussian random variables $X$, the kernel density estimator is nothing but the average of the densities of $n$ Gaussian random variables with individual means $x_k$, $k = 1, \\ldots, n,$ and common standard deviation $h.$\n\nTherefore, for a given sample you can run a kernel density estimation by taking the following steps:\n\n1. Check where each data point $x_k$ is located on the x-axis\n2. For each data point $x_k$ draw a Gaussian density $f_k$ with standard deviation $h$ and mean $x_k$\n3. For each $x \\in \\mathbb{R}$ check what are the values of $f_k$, $k = 1, \\ldots, n,$ at $x$ and average these.\n\nSo to create a visualization of the kernel density estimation principle, we simple create a function that plots each of those steps for us.\nFinally, we execute all of these functions and send them to `saveGIF()`.\n\nWe begin by computing the data we need to create the plots later on, i.e. we simulate a sample and compute the values of the densities.\n\n```{r}\ncompute_density <- function(x_0, h, K = dnorm) {\n  xx <- seq(-6, 6, 0.001) * h\n  tibble(\n    x = xx,\n    density = K((x - x_0) / h) / h\n  )\n}\n\nset.seed(123)\n# For the sake of demonstration we use a \n# small uniformly distributed sample here\nx_sample <- runif(5, -5, 5)\nh <- 1\n\n\ntib <- tibble(\n  k = seq_along(x_sample),\n  density = map(x_sample, compute_density, h = h)\n) %>%\n  unnest(density)\n```\n\nThen, it becomes time for our first step, i.e. check where the sample values are located.\n\n```{r}\ndraw_axis <- function(x_sample, tib) {\n  labs <- glue::glue(\"$x_{seq_along(x_sample)}$\")\n  labs <- latex2exp::TeX(labs)\n  p <- ggplot(data = NULL, aes(x = x_sample)) +\n    theme_minimal() +\n    theme(\n      axis.line.x = element_line(),\n      panel.grid = element_blank(),\n      axis.ticks = element_line(size = 1),\n      axis.text = element_text(size = 14)\n    ) +\n    scale_x_continuous(\n      limits = c(min(tib$x), max(tib$x)),\n      breaks = sort(x_sample),\n      minor_breaks = NULL,\n      labels = labs\n    ) +\n    scale_y_continuous(\n      breaks = NULL, \n      limits = c(0, max(tib$density) + 0.025)\n    ) +\n    labs(x = element_blank())\n  p\n}\n\n\np <- draw_axis(x_sample, tib)\np\n```\n\nOnce we have that, we draw the kernels.\n\n```{r}\ndraw_kernel <- function(p, tib) {\n  p <- p +\n    geom_line(data = tib, aes(x, density, group = k), size = 1) +\n    geom_segment(\n      aes(\n        x = x_sample,\n        xend = x_sample,\n        y = 0,\n        yend = dnorm(0)\n      ),\n      linetype = 2\n    ) +\n    labs(y = element_blank())\n  p\n}\ndraw_kernel(p, tib)\n```\n\nNext, average the densities at an arbitrary position $x_0.$\nIf we can do that, then we can iterate through different values of $x_0.$\n\n```{r}\nplot_until_x0 <- function(tib, x0) {\n  labs <- glue::glue(\"$x_{seq_along(x_sample)}$\")\n  labs <- latex2exp::TeX(labs)\n  tib_x0 <- tib %>%\n    filter(x <= x0) %>%\n    group_by(x) %>%\n    summarise(est = mean(density), .groups = \"drop\")\n\n\n  anim_col <- 'firebrick3'\n  g <- ggplot() +\n    geom_line(\n      data = tib,\n      aes(x, density, group = k),\n      alpha = 0.5,\n      size = 1\n    ) +\n    geom_point(\n      data = filter(tib, x == x0),\n      aes(x, density),\n      #col = anim_col,\n      alpha = 0.75,\n      size = 3\n    ) +\n    geom_vline(xintercept = x0, col = anim_col, alpha = 0.5) +\n    geom_point(\n      data = slice_tail(tib_x0, n = 1),\n      aes(x, est),\n      col = anim_col,\n      size = 3\n    ) +\n    geom_line(\n      data = tib_x0,\n      aes(x, est),\n      col = anim_col,\n      size = 1\n    ) +\n    theme_classic() +\n    theme(\n      axis.line.x = element_line(),\n      axis.line.y = element_blank(),\n      panel.grid = element_blank(),\n      axis.ticks = element_line(size = 1),\n      axis.text = element_text(size = 14)\n    ) +\n    scale_x_continuous(\n      limits = c(min(tib$x), max(tib$x)),\n      breaks = sort(x_sample),\n      minor_breaks = NULL,\n      labels = labs\n    ) +\n    scale_y_continuous(\n      breaks = NULL, \n      limits = c(0, max(tib$density) + 0.025)\n    ) +\n    labs(x = element_blank(), y = element_blank())\n\n  print(g)\n\n}\n\n\n\nx0 <- (0)\nplot_until_x0(tib, x0)\n```\n\nLast but not least, we may want to display the estimated density without the underlying kernels.\n\n```{r}\nfinal_plot <- function(tib) {\n  labs <- glue::glue(\"$x_{seq_along(x_sample)}$\")\n  labs <- latex2exp::TeX(labs)\n  tib_x0 <- tib %>%\n    group_by(x) %>%\n    summarise(est = mean(density), .groups = \"drop\")\n\n\n  anim_col <- 'firebrick3'\n  g <- tib_x0 %>%\n    ggplot() +\n    geom_line(\n      aes(x, est),\n      col = anim_col,\n      size = 1\n    ) +\n    theme_classic() +\n    theme(\n      axis.line.x = element_line(),\n      axis.line.y = element_blank(),\n      panel.grid = element_blank(),\n      axis.ticks = element_line(size = 1),\n      axis.text = element_text(size = 14)\n    ) +\n    scale_x_continuous(\n      limits = c(min(tib$x), max(tib$x)),\n      breaks = sort(x_sample),\n      minor_breaks = NULL,\n      labels = labs\n    ) +\n    scale_y_continuous(\n      breaks = NULL, \n      limits = c(0, max(tib$density) + 0.025)\n    ) +\n    labs(x = element_blank(), y = element_blank())\n\n  print(g)\n}\nfinal_plot(tib)\n```\n\nFinally, we have all the ingredients to create the animation by collecting all of these functions in a wrapper function and using it in conjunction with `saveGIF()`.\n\n```{r, eval = F}\ngif <- function(x_sample, tib) {\n  p <- draw_axis(x_sample, tib)\n  map(1:3, ~print(p))\n  p <- draw_kernel(p, tib)\n  map(1:5, ~print(p))\n  map(seq(min(tib$x), max(tib$x), 0.5), ~plot_until_x0(tib, .))\n  map(1:15, ~final_plot(tib))\n}\n\nsaveGIF(gif(x_sample, tib),\n        interval = 0.4, # animation speed\n        ani.width = 720,\n        ani.height = 405,\n        movie.name = \"kernelAnimation.gif\")\n\n```\n\n```{r, echo = F}\nknitr::include_graphics(\"kernelAnimation.gif\")\n```\n\n\nThus, we have created a short animation that illustrates the kernel density estimation procedure.\nProbably, there is some room for improving the animation by fine tuning the plots, tweaking with the animation speed or the number of frames.\nFor now, though, let us leave everything as it is.\n\nBut feel free to let me know what could be improved in the comments.\nSimilarly, if you want to leave any other form of feedback, feel free to roam the comment section too.\nFinally, if you enjoyed what you have seen here but do not want to bother writing a comment, you may simply hit the applause button instead. \n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["code-filename"],"toc":true,"toc-depth":3,"include-after-body":["../../footer.html"],"output-file":"01_visualize_kernel_density.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.35","editor":"source","theme":{"light":"../../theme.scss"},"title-block-banner":false,"author":"Albert Rapp","page-layout":"article","comments":{"utterances":{"repo":"AlbertRapp/blogComments"}},"title":"Animating kernel density estimators","date":"2021-07-14","categories":[],"description":"For my first post I create an animation using the animate package.","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}}}
{"title":"Interactive ggplots, user feedback, and a little bit of Javascript magic with Shiny","markdown":{"yaml":{"title":"Interactive ggplots, user feedback, and a little bit of Javascript magic with Shiny","date":"2022-01-17","categories":["Shiny"],"description":"Here's how I turned a ggplot interactive using Shiny and what else I learned while building that app","format":{"html":{"resources":["dummy_apps","interactive-ggplot"]}},"execute":{"message":false,"warning":false,"collapse":false},"editor_options":{"chunk_output_type":"console"}},"headingText":"| echo: false","containsRefs":false,"markdown":"\n\n```{r}\n#| results: 'hide'\nrenv::use(lockfile = \"renv.lock\")\n```\n\nI've been reading [Mastering Shiny by Hadley Wickham](https://mastering-shiny.org/) lately and one of the things that intrigued me is that you can make ggplots interactive. Though I believe that there are limitation to the level of interactiveness compared to using, say, [plotly](https://albert-rapp.de/post/2021-10-16-exploratory-intro-plotly/), I really wanted to practice interactive ggplots with Shiny. Naturally, I build a [Shiny app](https://rappa.shinyapps.io/interactive-ggplot/) to figure things out. Here's a demonstration of what the app can do. The rest of this chapter teaches you how some parts of the app were implemented.\n\n```{r, echo = F}\nknitr::include_graphics('Animation.gif')\n```\n\n## Working with clicks\n\nIf you have build at least one Shiny app, then you are probably aware that you can include plots on the UI with  `plotOutput()`. (If, in fact, you have never touched Shiny, then feel free to check out how I thought my students the [basics of Shiny](https://yards.albert-rapp.de/shiny-applications.html).)\nBut what you may not know, is that apart from its `outputId`, `width` and `height` arguments, this output function also uses arguments like `click` and `dblclick`. These are the secrets to unlocking interactiveness.\n\nImagine that you have a user interface that includes a plot output via\n\n```{r, eval = F}\nplotOutput('awesome_plot', click = 'awesome_click')\n```\n\nNow, what this small additional argument gives you is a way to access the coordinates of something the user clicks on. What you will have to do is to [observe `input$awesome_click`](https://albert-rapp.de/post/2021-11-21-a-few-learnings-from-a-simple-shiny-app/#create-and-observe-buttons). Here's a minimal example of how that works.\n\n```{r, eval = F}\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\nui <- fluidPage(\n  plotOutput('awesome_plot', click = 'awesome_click'),\n)\n\nserver <- function(input, output, session) {\n  # Create dummy data as reactive value\n  my_dat <- reactiveVal(tibble(x = 3, y = 4, msg = 'Click me'))\n  # Render plot with fixed coordinate system\n  output$awesome_plot <- renderPlot({\n    ggplot(data = my_dat()) +\n      geom_text(aes(x, y, label = msg), size = 15, vjust = 0, hjust = 0) +\n      coord_cartesian(xlim = c(0, 7), ylim = c(0, 8))\n  })\n  # Update dummy data on click \n  observeEvent(input$awesome_click, {\n    my_dat(\n      my_dat() %>% \n        mutate(\n          x = input$awesome_click$x,\n          y = input$awesome_click$y,\n          msg = if (runif(1) < 0.5) 'I like that. Do it again.' else 'Stop that!'\n        )\n    )\n  })\n}\n\nshinyApp(ui, server)\n```\n\n\nThis will give us the following app.\n\n```{r, echo = F}\nknitr::include_graphics('click_animation.gif')\n```\n\nLike a cat, this app is a master of mixed signals and wants to be touched but only a random amount of times. Unlike a cat, the app will show you a plot displaying its latest message at the most recently clicked spot.\n\nAll of this is powered by observing changes in `input$awesome_click` and then using this list's new x- and y-values to update the reactive value `my_dat` that underlies the plot. Notice that I have fixed the axes of the plot because otherwise the message will always be displayed in the middle of the plot. After all, the plot will be entirely rebuilt using new underlying data. Fundamentally, this is how I build the 'color my voronoi' from above.\n\nBut, of course, I have tried out more stuff like user feedback and even some javascript magic. Stick around if you want to learn these ancient skills as well. Destiny is calling.\n\n## Let your user know that he messed up and stop him before it's too late\n\nTo my surprise, UI elements like `numericInput()` do not actually check that an input is valid even though there are arguments like `min` and `max`. Of course, a user may end up giving wrong inputs that your app can't handle. We can't have that now, can we? \n\nWe will need to stop that insubordinate and churlish behavior immediately. In case you recognized that combination of 'insubordinate' and 'churlish', then I will have you now, yes, this is a reference to [Mr. Garvey](https://www.youtube.com/watch?v=Dd7FixvoKBw) and the rest of this section is a homage to a skit that makes me giggle every time.\n\nSo, let's build an app that works as follows:\n\n```{r,echo = F}\nknitr::include_graphics('name_animation.gif')\n```\n\nThe notifications in this app are all powered through the `shinyFeedback` package.\nIn order to activate its powers, drop a `shinyFeedback::useShinyFeedback()` in the UI like so.\n\n```{r, eval = F}\nlibrary(shiny)\nlibrary(dplyr)\n\nui <- fluidPage(\n  shinyFeedback::useShinyFeedback(),\n  h3('A Day with Mr. Garvey'),\n  textInput(\n    'name',\n    'What\\'s your name?',\n  )\n)\n```\n\nThen, you are all set up to activate warnings and notifications by your `server` function.\nHere is a simplified version of the app's remaining code.\n\n```{r,eval = F}\nnames <- c('Jay Quellin','Jacqueline', 'Balakay', 'Blake', 'Dee-nice', 'Denise',\n           'Ay-Ay-Ron', 'Aaron')\nreturn_msg <- function(name) {\n  case_when(\n    name == 'Balakay' ~ 'My name is Blake.',\n    name == 'Blake' ~ 'Do you wanna go to war, Balakay? You better check yourself!',\n    name == 'Jay Quellin' ~ 'Do you mean Jacqueline?',\n    name == 'Jacqueline' ~ 'So that\\'s how it\\'s going to be. I got my eye on you Jay Quellin!',\n    name == 'Dee-nice' ~ 'Do you mean Denise?',\n    name == 'Denise' ~ 'You say your name right!',\n    name == 'Ay-Ay-Ron' ~ 'It is pronounced Aaron.',\n    name == 'Aaron' ~ 'You done messed up Ay-Ay-Ron!'\n  )\n}\n\nserver <- function(input, output, session) {\n  name_input <- reactive(input$name) \n  observeEvent(name_input(), {\n    shinyFeedback::feedbackDanger(\n      'name',\n      show = (name_input() %in% names),\n      text = return_msg(name_input())\n    )\n    \n    shinyFeedback::feedbackSuccess(\n      'name',\n      show = !(name_input() %in% names),\n      text = 'Thank you!'\n    )\n  })\n}\n\nshinyApp(ui, server)\n```\n\nAs you can see, the feedback functions work with\n\n* the `name` of an input, \n* a rule when to `show` up and \n* a `text` to display.\n\nThis code is pretty straightforward but, unfortunately, this app does not work like the one you have seen above. There are a couple of problems:\n\n- For starters, if you start the app, then the text input is empty, so `!(name_input() %in% names)` is true and the app will immediately display \"Thank you!\"\n- After you write a name on the list of defined names, then no warning will be displayed. That is because the later `feedbackSuccess()` will always command that there is nothing to display.\n\nTherefore, we need something that stops the `feedbackSuccess()` from executing when we don't need it. This can be achieved through the little but powerful `req()` function. It checks that all given conditions are met or stops the execution where it is. In this case, you will need to drop `req(name_input(), !(name_input() %in% names))` in front of `feedbackSuccess()`.\n\nSmall technical detail: Notice that `name_input()` will be `''` in the beginning. Technically, this is not a boolean but that doesn't matter to Shiny. What matters is that `''` is not \"truthy\". See `?isTruthy` for more details.\n\nNow, even with this small change. Our app won't run smoothly because sometimes the notifaction will not change from \"success\" to \"danger\". This is is because sometimes the notifaction needs to be reseted to work with new notifications. Therefore, a `hideFeedback()` is in order.\n\nAlso, if you are not fast at typing, then a notification might already show up, when you are still typing. It is rude to interrupt our kind user like this. Therefore, let's make sure our app waits a little before giving out notifications.  We can let out app wait for a defined amount of milliseconds by sending our reactive `name_input()` to `debounce()`. In total, our `server` function now looks like this.\n\n```{r, eval = F}\nserver <- function(input, output, session) {\n  name_input <- reactive(input$name) %>% debounce(250)\n  observeEvent(name_input(), {\n    shinyFeedback::hideFeedback('name')\n    \n    shinyFeedback::feedbackDanger(\n      'name',\n      show = (name_input() %in% names),\n      text = return_msg(name_input())\n    )\n    \n    req(name_input(), !(name_input() %in% names))\n    shinyFeedback::feedbackSuccess(\n      'name',\n      show = !(name_input() %in% names),\n      text = 'Thank you!'\n    )\n  })\n}\n```\n\nFinally, let me mention that, within the function `req()`, it is also possible to set `cancelOutput = TRUE`. This stops the code execution as usual but avoids destroying previously displayed outputs.\n\n## Sprinkle some javascript magic on top of your app\n\nFor my final trick before I disappear into the ether, let me show you a little bit of javascript.\nAs I, myself, do not know much about JS, I am particularly proud that I included some of that web magic into my voronoi coloring app.\n*'What did you do?'*, you ask? Well, did you notice that the colour dropdown menu in the voronoi app contains the actual colors next to the color names?\nThat is some JS magic right there! Impressive, I know.\n\nTo make that work, I had to use the `options` argument of `selectizeInput()` together with the `render()` function and some actual JS code. The whole thing is adapted from [this SO post](https://stackoverflow.com/questions/54522970/shiny-selectizeinput-with-value-and-label-fields/54530077#54530077) and looks like this:\n\n```{r, eval = F}\ncol2hex <- gplots::col2hex\ncolorValues <- colors()\ncolorNames <- glue::glue(\"{colorValues} <span style='background-color:{col2hex(colorValues)}'>{rep('&nbsp;', 15) %>% stringr::str_c(collapse = '')}</span>\")\ncolors <- setNames(colorValues, colorNames)\njs_render_string <- I(\"\n  {\n    item: function(item, escape) { return '<div>' + item.label + '</div>'; },\n    option: function(item, escape) { return '<div>' + item.label + '</div>'; }\n  }\")\nselectizeInput(\n  \"color\",\n  \"Colour\",\n  selected = 'grey80',\n  choices = colors,\n  options = list(render = js_render_string)\n)\n```\n\nLet's untangle this step by step. The first part of this code gives us a vector `colors` containing the color names like \"white\" and \"aliceblue\" as **values**. The same vector also uses **names** for the vector elements that will be displayed to the user. In principal, this `colors` vector looks like this:\n\n```{r}\nx <- c('white', 'aliceblue') # no names\nx\nx <- setNames(x, c('name1', 'name2')) # with names\nx\nx['name1'] # named vectors can be used like dictionaries\n```\n\nIn our color example, instead of using arbitrary names, I converted the color names to their hexvalues like `#FFFFFF` and wrapped those in some HTML code that could potentially look like `\"<span style='background-color#FFFFFF'>white</span>\"`. This corresponds to the word `white` with background color `#FFFFFF` (also white - unspectacular).\n\nBut in the actual app I wanted to have colored bars next to the color names. Thus, I have used the HTML code for white space `&nbsp;` and made this into `\"white <span style='background-color#FFFFFF'>&nbsp;</span>\"`. Now, to make that color bar longer, I repeated whited space with `rep()` and glued those into a single string using `stringr::str_c()`.\nThis is what the vector looks like if I only use two white space repeats.\n\n```{r}\nlibrary(dplyr, warn.conflicts = F)\ncol2hex <- gplots::col2hex\ncolorValues <- colors()\ncolorNames <- glue::glue(\"{colorValues} <span style='background-color:{col2hex(colorValues)}'>{rep('&nbsp;', 2) %>% stringr::str_c(collapse = '')}</span>\")\ncolors <- setNames(colorValues, colorNames)\ncolors[1]\ncolors[2]\n```\n\nIn the dropdown menu of the app the user will see the names of the color vector, i.e. the HTML code and within the server function of our app the selection will then correspond to the actual value of the vector, i.e. the color name without the html stuff. \n\nIn our dummy example from above, the user would see `name1` and `name2` in the dropdown menu but within the server function a user's selection would correspond to `input$color` which would evaluate to `white` or `aliceblue`.\n\nClearly, we don't want the user to see the raw HTML code. This is where JS comes into play. The code that is stored in `js_render_string` evaluates the HTML code in order to display the actual colors instead of the raw code. Finally, to execute the JS code we need to pass it to the options of `selectizeInput` via `options = list(render = js_render_string)`.\n\nThere you go, this is how I created the color bars in my app using a JS snippet I found on Stackoverflow. You can find the complete codes of the apps we've build [here (click app)](dummy_apps/click_app.R), [here (notification names app)](dummy_apps/name_app.R) and [here (voronoi coloring app)](interactive-ggplot/app.R). If you liked this post and want to see more Shiny posts, let me know in the comments or simply hit the applause button below. Of course, you can also always follow my work via [Twitter](https://twitter.com/rappa753)."},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["code-filename","lightbox"],"toc":true,"toc-depth":3,"include-after-body":["../../footer.html"],"output-file":"08_drawing_ggplot_interactively.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.35","lightbox":"auto","editor":"source","theme":{"light":"../../theme.scss"},"title-block-banner":false,"author":"Albert Rapp","page-layout":"article","comments":{"utterances":{"repo":"AlbertRapp/blogComments"}},"title":"Interactive ggplots, user feedback, and a little bit of Javascript magic with Shiny","date":"2022-01-17","categories":["Shiny"],"description":"Here's how I turned a ggplot interactive using Shiny and what else I learned while building that app","editor_options":{"chunk_output_type":"console"},"resources":["dummy_apps","interactive-ggplot"]},"extensions":{"book":{"multiFile":true}}}}}
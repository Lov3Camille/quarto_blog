{
  "hash": "cad6820fba71cdf7c6c92a39aced8c83",
  "result": {
    "markdown": "---\ntitle: 'Storytelling in ggplot using rounded rectangles'\ndate: '2022-05-04'\ncategories: [\"Visualization\"]\ndescription: \"We build rebuild a 'Storytelling with Data' plot which uses rounded rectangles. I'll show you an easy and a hard way to make rectangles round.\"\nexecute: \n  message: false\n  warning: false\n  collapse: false\nformat:\n  html:\n    resources:\n      - ratios.csv\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\nA standard ggplot output can rarely convey a powerful message.\nFor effective data visualization you need to customize your plot.\n[A couple of weeks ago](https://albert-rapp.de/posts/ggplot2-tips/10_recreating_swd_look/10_recreating_swd_look.html), \nI showed you how.\n\nIn this blog post, I will rebuild another great data viz from scratch.\nIf you have read my original blog post, then you won't have to learn many new tricks.\nMost of the techniques that I use can be found there.\nThis is also why I save explanations only for the parts that are new.\nThis should keep this blog post a bit shorter.\nYou're welcome.\n\nNevertheless, in today's installment of my [ggplot2 series](https://albert-rapp.de/ggplot-series.html) \nI will teach you something truly special.\nI will teach you how to create...\\*drum roll\\*...rounded rectangles.\nSounds exciting, doesn't it?\nWell, maybe not.\nBut it looks great.\nCheck out what we'll build today.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](final_remake.png){width=944}\n:::\n:::\n\n\nThis plot comes to you via another excellent entry of the [storytelling with data (SWD) blog](https://www.storytellingwithdata.com/blog/bar-charts-and-dot-plots-and-line-graphs-oh-my).\nTo draw rectangles with rounded rectangles we can leverage the [ggchicklet package](https://github.com/hrbrmstr/ggchicklet).\nThough, for some mysterious reason, the `geom_*` that we need is hidden in that package.\nTherefore, we will have to dig it out.\nThat's the easy way to do it.\nAnd honestly, this is probably also the practical way to do it.\n\nHowever, every now and then I want to do things the hard way.\nSo, my dear reader, this is why I will also show you how to go from rectangles to rounded rectangles the hard way.\nBut only after showing you the easy way first, of course.\nOnly then, in the second part of this blog post, will I take the sadistically-inclined among you on a tour to the world of grobs.\n\nGrobs, you say?\n[Is that an instrument](https://www.youtube.com/watch?v=71GWS3ccmvI)?\nNo, Patrick, it is an **gr**aphical **ob**ject.\nUnder the hood, we can transform a ggplot to a list of graphical objects.\nAnd with a few hacks, we can adjust that list.\nThis way, the list will contain not `rectGrobs` but `roundrectGrobs`.\nThen, we can put everything back together, close the hood and enjoy our round rectangles.\nNow, enough intro, let's go.\n\n\n## Basic plot\n\nFirst, let us recreate the \"bad\" plot that the above SWD blog post remodels.\nIn the end, we will work on the remodeled data viz too.\nAs always, though, there is something to be learnt from [creating an ugly plot](https://www.allisonhorst.com/post/do-your-worst/).\nSo, here's the beast that we will build.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Source: [Storytelling with data (SWD) blog](https://www.storytellingwithdata.com/blog/bar-charts-and-dot-plots-and-line-graphs-oh-my)](before_plot.png){width=100%}\n:::\n:::\n\n\n### Read data\n\nI didn't find the underlying data and had to guess the values from the plot.\nThus, I probably didn't get the values exactly right.\nBut for our purposes this should suffice.\nIf you want, you can download the European csv-file that I created [here](https://albert-rapp.de/posts/ggplot2-tips/11_rounded_rectangles/ratios.csv).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# Use read_csv2 because it's an European file\ndat <- read_csv2('ratios.csv')\n```\n:::\n\n\n### Compute averages \n\nLet me point out that taking the average of the ratios may not necessarily give \nan appropriate result (in a statistical kind of sense).\nBut, once again, this should not bother us as we only want to learn how to plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\navgs <- dat %>% \n  pivot_longer(\n    cols = -1,\n    names_to = 'type',\n    values_to = 'ratio'\n  ) %>% \n  group_by(type) %>% \n  summarise(ratio = mean(ratio)) %>% \n  mutate(location = 'REGION AVERAGE')\navgs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  type               ratio location      \n  <chr>              <dbl> <chr>         \n1 inventory_turnover  9.78 REGION AVERAGE\n2 store_lower         7.11 REGION AVERAGE\n3 store_upper        12.1  REGION AVERAGE\n```\n:::\n\n```{.r .cell-code}\n### Combine with data \ndat_longer <- dat %>% \n  pivot_longer(\n    cols = -1,\n    names_to = 'type',\n    values_to = 'ratio'\n  ) \ndat_longer_with_avgs <- dat_longer %>% \n  bind_rows(avgs)\n```\n:::\n\n\n\n\n### Create bars\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Colors we will use throughout this blog post\ncolor_palette <- thematic::okabe_ito(8)\n\n# Make sure that bars are in the same order as in the data set\ndat_factored <- dat_longer %>% \n  mutate(location = factor(location, levels = dat$location)) \n\np <- dat_factored %>% \n  ggplot(aes(location, ratio)) +\n  geom_col(\n    data = filter(dat_factored, type == 'inventory_turnover'),\n    fill = color_palette[2]\n  ) +\n  theme_minimal()\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n### Turn labels and get rid of axis text\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p +\n  labs(x = element_blank(), y = element_blank()) +\n  theme(\n    axis.text.x = element_text(angle = 50, hjust = 1)\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n### Remove expansion to get x-labels closer to the bars\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p + coord_cartesian(ylim = c(0, 30), expand = F)\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### Remove other grid lines\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p + \n  theme(\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.major.y = element_line(colour = 'black', size = 0.75)\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n### Format y-axis\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p +\n  scale_y_continuous(\n    breaks = seq(0, 30, 5),\n    labels = scales::label_comma(accuracy = 0.1)\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n### Add points\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p +\n  geom_point(\n    data = filter(dat_factored, type == 'store_lower'),\n    col = color_palette[1],\n    size = 3\n  ) +\n  geom_point(\n    data = filter(dat_factored, type == 'store_upper'),\n    col = color_palette[3],\n    size = 3\n  ) \np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### Add average lines\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- p +\n  geom_hline(\n    yintercept = avgs[[3, 'ratio']], \n    size = 2.5, \n    col = color_palette[3]\n  ) +\n  geom_hline(\n    yintercept = avgs[[2, 'ratio']], \n    size = 2.5, \n    col = color_palette[1]\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### Add text labels\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np +\n  geom_text(\n    data = filter(dat_factored, type == 'inventory_turnover'),\n    aes(label = scales::comma(ratio, accuarcy = 0.1)),\n    nudge_y = 0.8,\n    size = 2.5\n  )\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n## Improved plot\n\nNow, let us begin building the improved plot.\nFirst, let us get the long labels onto the y-axis and use regular rectangles before we worry about the rounded rectangles. \n\n### Flip axes and use rectangles to show upper and lower bounds.\n\nUnfortunately, `geom_rect()` does not work as intended.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\ndat_with_avgs <- dat_longer_with_avgs %>% \n  pivot_wider(\n    names_from = 'type',\n    values_from = 'ratio'\n  ) \n\ndat_with_avgs %>% \n  ggplot() +\n  geom_rect(\n    aes(\n      xmin = store_lower, \n      xmax = store_upper, \n      ymin = location, \n      ymax = location\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nInstead, let us create a new numeric column containing a location's rank based on its `inventory_turnover`.\nThis is done with `row_number()`.\nWhile we're at it, let us create a new tibble that also contains information on the colors each geom will use.\nThen, we can map to these new columns in ggplot and make sure that the values are used as is by setting `scale_*_identity()`.\nThis is one convenient way to control the aesthetics of each geom [without functional programming](http://albert-rapp.de/posts/ggplot2-tips/09_functional_programming_ggplot/09_functional_programming_ggplot.html#how-do-i-manually-set-aesthetics-with-aes-and-scale__identity).\nWith the image from above in mind, we know that our final plot will need \n\n* different `col`, `fill` and `size` values in `geom_point()` \n* different `fill` and `alpha` values in `geom_rect()`\n\nHere's what this tibble looks like.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nbar_height <- 0.4 \nno_highlight_col <- 'grey70'\naverage_highlight_col <- 'grey40'\nbelow_highlight <- color_palette[2]\n\nsorted_dat <- dat_with_avgs %>% \n  mutate(num = row_number(inventory_turnover)) %>% \n  # Sort so that everything is in order of rank\n  # Important for text labels later on\n  arrange(desc(num)) %>% \n  mutate(\n    rect_color = case_when(\n      inventory_turnover < store_lower ~ below_highlight,\n      location == 'REGION AVERAGE' ~ average_highlight_col,\n      T ~ no_highlight_col\n    ),\n    rect_alpha = if_else(\n      inventory_turnover < store_lower,\n      0.5,\n      1\n    ),\n    point_color = if_else(\n      inventory_turnover < store_lower,\n      below_highlight,\n      'black'\n    ),\n    point_fill = if_else(\n      inventory_turnover < store_lower,\n      below_highlight,\n      'white'\n    ),\n    point_size = if_else(\n      inventory_turnover < store_lower,\n      3,\n      2\n    )\n  )\nsorted_dat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 24 × 10\n   locat…¹ inven…² store…³ store…⁴   num rect_…⁵ rect_…⁶ point…⁷ point…⁸ point…⁹\n   <chr>     <dbl>   <dbl>   <dbl> <int> <chr>     <dbl> <chr>   <chr>     <dbl>\n 1 Castle…    14.7    24.3    20      24 #009E73     0.5 #009E73 #009E73       3\n 2 Wellsv…    13.6     7.6     2.5    23 grey70      1   black   white         2\n 3 Basin …    12.7     8       4.5    22 grey70      1   black   white         2\n 4 Atlant…    12.3    12.8     7.8    21 grey70      1   black   white         2\n 5 Neverl…    12.1    18      13.4    20 #009E73     0.5 #009E73 #009E73       3\n 6 Bluffi…    11.7     4.2     3      19 grey70      1   black   white         2\n 7 Bikini…    11.6    12.5     7.8    18 grey70      1   black   white         2\n 8 Metrop…    11.3    24      11.3    17 grey70      1   black   white         2\n 9 Hill V…    11      22       7.5    16 grey70      1   black   white         2\n10 Venusv…    10.4    15.5    12.3    15 #009E73     0.5 #009E73 #009E73       3\n# … with 14 more rows, and abbreviated variable names ¹​location,\n#   ²​inventory_turnover, ³​store_upper, ⁴​store_lower, ⁵​rect_color, ⁶​rect_alpha,\n#   ⁷​point_color, ⁸​point_fill, ⁹​point_size\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nNow, we can create our plot.\nNotice that I set `shape = 21` in `geom_point()` to use both the `fill` and `col` aesthetic.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nsorted_dat %>% \n  ggplot() +\n  geom_rect(\n    aes(\n      xmin = store_lower, \n      xmax = store_upper, \n      ymin = num - bar_height, \n      ymax = num + bar_height, \n      fill = rect_color,\n      alpha = rect_alpha\n    ),\n  ) +\n  geom_point(\n    aes(\n      x = inventory_turnover,\n      y = num,\n      fill = point_fill,\n      col = point_color,\n      size = point_size\n    ),\n    shape = 21,\n    stroke = 1\n  ) +\n  scale_fill_identity() +\n  scale_color_identity() +\n  scale_size_identity() +\n  scale_alpha_identity() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### Use ggchicklet for rounded rectangles\n\nThe whole point of this blog post is to use rounded rectangles.\nSo let's do that. \nThe [ggchicklet package](https://github.com/hrbrmstr/ggchicklet) has a geom called\n`geom_rrect()`.\nIt works just like `geom_rect()` but accepts another value `r` which is used to\ndetermine the radius of the rounded rectangles.\nUnfortunately, this geom is not an exported function of this package.\nThis means that if you write `ggchicklet::` (e.g. in RStudio) and press `TAB` you won't see `geom_rrect()`.\nThus, you have to access the internal function via `:::` (three colons).\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- sorted_dat %>% \n  ggplot() +\n  ggchicklet:::geom_rrect(\n    aes(\n      xmin = store_lower, \n      xmax = store_upper, \n      ymin = num - bar_height, \n      ymax = num + bar_height, \n      fill = rect_color,\n      alpha = rect_alpha\n    ),\n    # Use relative npc unit (values between 0 and 1)\n    # This ensures that radius is not too large for your canvas\n    r = unit(0.5, 'npc')\n  ) +\n  geom_point(\n    aes(\n      x = inventory_turnover,\n      y = num,\n      fill = point_fill,\n      col = point_color,\n      size = point_size\n    ),\n    shape = 21,\n    stroke = 1\n  ) +\n  scale_fill_identity() +\n  scale_color_identity() +\n  scale_size_identity() +\n  scale_alpha_identity() +\n  theme_minimal()\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n### Remove grid lines, move axis and add some text elements\n\nWe will set the y-axis labels manually later on.\nOtherwise, we cannot change its colors one-by-one.\nFor now, let's get rid of superfluous grid lines, move the x-axis and add a title.\n\nNotice that I draw the axis line manually with a segment annotation.\nThis seems weird, I know.\nUnfortunately, it cannot be helped because I still need room for the y-axis labels.\nAnd if I do not plot the axis line manually, then the axis line will start all the way to the left.\nMake sure that you set `clip = 'off'` in `coord_cartesian()` for the annotation to be displayed.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\ntitle_lab <- 'Review stores with turnover ratios that are below their\\nforecasted range'\ntitle_size <- 14\naxis_label_size <- 8\ntext_size <- 18\np <- p +\n  scale_x_continuous(\n    breaks = seq(0, 25, 5),\n    position = 'top'\n  ) +\n  coord_cartesian(\n    xlim = c(-5, 25), \n    ylim = c(0.75, 24.75),  \n    expand = F,\n    clip = 'off'\n  ) +\n  annotate(\n    'segment',\n    x = 0,\n    xend = 25,\n    y = 24.75,\n    yend = 24.75,\n    col = no_highlight_col,\n    size = 0.25\n  ) +\n  labs(\n    x = 'INVENTORY TURNOVER RATIO',\n    y = element_blank(),\n    title = title_lab\n  ) +\n  theme(\n    text = element_text(\n      size = text_size,\n      color = average_highlight_col\n    ),\n    plot.title.position = 'plot',\n    panel.grid = element_blank(),\n    axis.title.x = element_text(\n      size = axis_label_size,\n      hjust = 0.21,\n      color = no_highlight_col\n    ),\n    axis.text.x = element_text(\n      size = axis_label_size,\n      color = no_highlight_col\n    ),\n    axis.ticks.x = element_line(color = no_highlight_col, size = 0.25),\n    axis.text.y = element_blank(),\n    axis.line.x = element_blank()\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n### Add y-axis labels\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\ny_axis_text_size <- 3\np +\n  geom_text(\n    aes(\n      x = 0,\n      y = num,\n      label = location,\n      col = no_highlight_col,\n      hjust = 1,\n      size = y_axis_text_size\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n### Highlight words\n\nLet us turn to text highlights.\nFor that we will need `ggtext`.\nThis will let us use `geom_richtext()` instead of `geom_text()`.\nNotice that I have note saved the last `geom_text()` modification in `p`.\nOtherwise, we would get two overlapping layers of text.\nYou can highlight single words as demonstrated in my [blog post about effective use of colors](https://albert-rapp.de/posts/ggplot2-tips/07_four_ways_colors_more_efficiently/07_four_ways_colors_more_efficiently.html).\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nlibrary(ggtext)\nsorted_dat_with_new_labels <- sorted_dat %>% \n  mutate(location_label = case_when(\n    inventory_turnover < store_lower ~ glue::glue(\n      '<span style = \"color:{below_highlight}\">**{location}**</span>'\n    ),\n    location == 'REGION AVERAGE' ~ glue::glue(\n      '<span style = \"color:{average_highlight_col}\">**{location}**</span>'\n    ),\n    T ~ location\n  ))\n\np <- p +\n  geom_richtext(\n    data = sorted_dat_with_new_labels,\n    aes(\n      x = 0,\n      y = num,\n      label = location_label,\n      col = no_highlight_col,\n      hjust = 1,\n      size = y_axis_text_size\n    ),\n    label.colour = NA,\n    fill = NA\n  )\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nFantastic!\nNext, we only have to highlight words in our call to action.\nMake sure that `plot.title` in `theme()` is an `element_markdown()`. \n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\ntitle_lab_adjusted <- glue::glue(\n  \"Review stores with **turnover ratios** that are <span style = 'color:{below_highlight}'>below their</span><br><span style = 'color:#7fceb9;'>**forecasted range**</span>\"\n)\n\np +\n  labs(title = title_lab_adjusted) +\n  theme(\n    plot.title = element_markdown(),\n    panel.background = element_rect(color = NA, fill = 'white')\n  )\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nThere you go.\nThis concludes the easy way to draw rounded rectangles with `ggplot2` and `ggchicklet`.\nNow, I am well aware that this is probably the moment when many readers will \ndrop out.\nSo, let me do some shameless self-promotion before everyone's gone.\n\nIf you enjoyed this post, follow me on [Twitter](https://twitter.com/rappa753) \nand/or subscribe to my [RSS feed](https://albert-rapp.de/blog.xml). \nFor reaching out to me, feel free to hit the comments or send me a mail. \nI am always happy to see people commenting on my work.\n\n## Rounded rectangles with grobs\n\nAlright, this is where the hacking begins.\nIn this last part of the blog post, I will show you to how transform rectangles to\nrounded rectangles.\nIn principle, you could then create our SWD plot using `geom_rect()` and transform\nthe rectangles afterwards.\nNo additional package needed.\n\n### Simple example with one bar\n\nLet me demonstrate a quick hack when there is only one bar in the plot.\nUnfortunately, this does not work with more than one bar.\nStill, this should get you acquainted with grobs.\nFirst, create a simple dummy plot.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\np <- mpg %>%\n  filter(year == 2008) %>% \n  ggplot(aes(year)) +\n  geom_bar() +\n  theme_minimal()\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nNext, we can turn this plot into a so-called `TableGrob`.\nFrom what I understand, it is a highly nested list that contains all the graphical objects (grobs) that are part of our plot `p`.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nl <- ggplotGrob(p)\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTableGrob (12 x 9) \"layout\": 18 grobs\n    z         cells       name                                          grob\n1   0 ( 1-12, 1- 9) background       zeroGrob[plot.background..zeroGrob.831]\n2   5 ( 6- 6, 4- 4)     spacer                                zeroGrob[NULL]\n3   7 ( 7- 7, 4- 4)     axis-l           absoluteGrob[GRID.absoluteGrob.820]\n4   3 ( 8- 8, 4- 4)     spacer                                zeroGrob[NULL]\n5   6 ( 6- 6, 5- 5)     axis-t                                zeroGrob[NULL]\n6   1 ( 7- 7, 5- 5)      panel                      gTree[panel-1.gTree.814]\n7   9 ( 8- 8, 5- 5)     axis-b           absoluteGrob[GRID.absoluteGrob.817]\n8   4 ( 6- 6, 6- 6)     spacer                                zeroGrob[NULL]\n9   8 ( 7- 7, 6- 6)     axis-r                                zeroGrob[NULL]\n10  2 ( 8- 8, 6- 6)     spacer                                zeroGrob[NULL]\n11 10 ( 5- 5, 5- 5)     xlab-t                                zeroGrob[NULL]\n12 11 ( 9- 9, 5- 5)     xlab-b titleGrob[axis.title.x.bottom..titleGrob.823]\n13 12 ( 7- 7, 3- 3)     ylab-l   titleGrob[axis.title.y.left..titleGrob.826]\n14 13 ( 7- 7, 7- 7)     ylab-r                                zeroGrob[NULL]\n15 14 ( 4- 4, 5- 5)   subtitle         zeroGrob[plot.subtitle..zeroGrob.828]\n16 15 ( 3- 3, 5- 5)      title            zeroGrob[plot.title..zeroGrob.827]\n17 16 (10-10, 5- 5)    caption          zeroGrob[plot.caption..zeroGrob.830]\n18 17 ( 2- 2, 2- 2)        tag              zeroGrob[plot.tag..zeroGrob.829]\n```\n:::\n:::\n\n\nIn this case, calling `l` gave us an overview of plot parts.\nWe will want to change stuff in the panel.\nThus, let us extract the grobs from the sixth list entry of `l`.\nAs we have seen in the table, this will give us a `gTree`.\nThat's another nested list.\nAnd it contains an interesting sublist called `children`.\nThat's where the grobs of this `gTree` are stored.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\ngrobs <- l$grobs[[6]]\ngrobs$children\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(gTree[grill.gTree.812], zeroGrob[NULL], rect[geom_rect.rect.800], zeroGrob[NULL], zeroGrob[panel.border..zeroGrob.801]) \n```\n:::\n:::\n\n\nHere, the `rect` grob is what we want to access.\nThus, let us take a look what we can find there.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\n# str() helps us to unmask the complicated list structure\ngrobs$children[[3]] %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 10\n $ x     : 'simpleUnit' num 0.0455native\n  ..- attr(*, \"unit\")= int 4\n $ y     : 'simpleUnit' num 0.955native\n  ..- attr(*, \"unit\")= int 4\n $ width : 'simpleUnit' num 0.909native\n  ..- attr(*, \"unit\")= int 4\n $ height: 'simpleUnit' num 0.909native\n  ..- attr(*, \"unit\")= int 4\n $ just  : chr [1:2] \"left\" \"top\"\n $ hjust : NULL\n $ vjust : NULL\n $ name  : chr \"geom_rect.rect.800\"\n $ gp    :List of 6\n  ..$ col     : logi NA\n  ..$ fill    : chr \"#595959FF\"\n  ..$ lwd     : num 1.42\n  ..$ lty     : num 1\n  ..$ linejoin: chr \"mitre\"\n  ..$ lineend : chr \"square\"\n  ..- attr(*, \"class\")= chr \"gpar\"\n $ vp    : NULL\n - attr(*, \"class\")= chr [1:3] \"rect\" \"grob\" \"gDesc\"\n```\n:::\n:::\n\n\nThis is a grob.\nIt can be build using `grid::rectGrob()`.\nBasically, what you see here is a specification of everything from `x` and `y` position to graphical properties (`gp`) of this rectangular grob.\n\nThere is also a function `grid::roundrectGrob()`.\nAs you may have guessed, it builds the rounded rectangle grobs that we so desperately crave.\nFrom `grid::roundrectGrob()`'s documentation, we know that we will have to specify another variable `r` to determine the radius of the rounded rectangles.\nSo, here's what we could do now.\n\n1. Extract `x`, `y`, `gp` and so on from `grobs$children[[3]]`.\n2. Add another argument `r`.\n3. Pass all of these arguments to `grid::roundrectGrob()`\n4. Exchange `grobs$children[[3]]` with our newly built `roundrectGrob`\n\nThis is what we will have to do at some point.\nBut in this simple plot, I want to show you a different hack.\nDid you notice the `class` [attributes](https://adv-r.hadley.nz/vectors-chap.html#attributes) of `grobs$children[[3]]`?\nSomewhere in there it says `- attr(*, \"class\")= chr [1:3] \"rect\" \"grob\" \"gDesc\"`.\nAnd we can access and change that information through `attr()`.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nattr(grobs$children[3][[1]], 'class')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"rect\"  \"grob\"  \"gDesc\"\n```\n:::\n:::\n\n\nNow, a really basic hack is to \n\n1. change the class attribute from `rect` to `roundrect`.\n2. stick another argument `r` into the list\n3. put everything back together as if nothing happened\n\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\n## Change class attribute of grobs$children[3][[1]] from rect to roundrect\ncurrent_attr <-  attr(grobs$children[3][[1]], 'class')\nnew_attr <- str_replace(current_attr, 'rect', 'roundrect')\nattr(grobs$children[3][[1]], 'class') <- new_attr\n\n# Add r argument for grid::roundrectGrob()\n# We need to add a \"unit\"\n# Here I use the relative unit npc\ngrobs$children[3][[1]]$r <- unit(0.5, 'npc')\n\n# Copy original list and change grobs in place\nl_new <- l\nl_new$grobs[[6]] <- grobs\n\n# Draw grobs via grid::grid.draw()\ngrid::grid.newpage()\ngrid::grid.draw(l_new)\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### Dealing with multiple bars\n\nThe previous hack works if we plot only one bar. However, if there are multiple `x` arguments, then `grid::roundrectGrob()` will error. It seems like that function is not vectorized. So, we will build the rounded rectangles ourselves with functional programming.\nFirst let's take a look at the plot that we want to modify.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\np <- mpg %>%\n  ggplot(aes(class, fill = class)) +\n  geom_bar() +\n  theme_minimal()\np\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nNow, let's find out what arguments `grid::roundrectGrob()` accepts and extract\nas many of these from `grobs$children[3]` as possible.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nl <- ggplotGrob(p)\ngrobs <- l$grobs[[6]]\n\n# What arguments does roundrectGrob need?\narg_names <- args(grid::roundrectGrob) %>% as.list() %>% names()\n# Somehow last one is NULL\narg_names <- arg_names[-length(arg_names)]\narg_names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"x\"             \"y\"             \"width\"         \"height\"       \n [5] \"default.units\" \"r\"             \"just\"          \"name\"         \n [9] \"gp\"            \"vp\"           \n```\n:::\n\n```{.r .cell-code}\n# Extract the arguments roundrectGrob needs from grobs$children[3]\nextracted_args <- map(arg_names, ~pluck(grobs$children[3], 1, .)) \nnames(extracted_args) <- arg_names\nextracted_args %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 10\n $ x            : 'simpleUnit' num [1:7] 0.0208native 0.16native 0.299native 0.438native 0.576native ...\n  ..- attr(*, \"unit\")= int 4\n $ y            : 'simpleUnit' num [1:7] 0.119native 0.735native 0.647native 0.207native 0.529native ...\n  ..- attr(*, \"unit\")= int 4\n $ width        : 'simpleUnit' num [1:7] 0.125native 0.125native 0.125native 0.125native 0.125native 0.125native 0.125native\n  ..- attr(*, \"unit\")= int 4\n $ height       : 'simpleUnit' num [1:7] 0.0733native 0.689native 0.601native 0.161native 0.484native ...\n  ..- attr(*, \"unit\")= int 4\n $ default.units: NULL\n $ r            : NULL\n $ just         : chr [1:2] \"left\" \"top\"\n $ name         : chr \"geom_rect.rect.911\"\n $ gp           :List of 6\n  ..$ col     : logi [1:7] NA NA NA NA NA NA ...\n  ..$ fill    : chr [1:7] \"#F8766D\" \"#C49A00\" \"#53B400\" \"#00C094\" ...\n  ..$ lwd     : num [1:7] 1.42 1.42 1.42 1.42 1.42 ...\n  ..$ lty     : num [1:7] 1 1 1 1 1 1 1\n  ..$ linejoin: chr \"mitre\"\n  ..$ lineend : chr \"square\"\n  ..- attr(*, \"class\")= chr \"gpar\"\n $ vp           : NULL\n```\n:::\n:::\n\n\nAs you can can see, in our vector `extracted_args` the components `x`, `y` and so on are vectors of length 7 (since we have 7 bars in `p`).\nAs I said before, this works because it is a `rectGrob`. \nBut, with a `roundrectGrob` this would cause errors.\n\nNext, let us make sure that we know how many rectangles we need to change.\nAlso, we will need to specify the radius `r`, and the graphical parameters `gp` should always have the same amount of arguments.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\n## How many rectangles are there?\nn_rects <- extracted_args$x %>% length()\n\n## Add radius r\nextracted_args$r <- unit(rep(0.25, n_rects), 'npc')\n\n## Make sure that all list components in gp have equally many values\nextracted_args$gp$linejoin <- rep(extracted_args$gp$linejoin, n_rects)\nextracted_args$gp$lineend <- rep(extracted_args$gp$lineend, n_rects)\n```\n:::\n\n\nNow comes the tedious part.\nWe have to split up `extracted_args` into multiple nested lists.\nUnfortunately, the `purrr` package does not provide a function that works the way\nwe want.\nThat's because we need many custom steps here.\nFor instance, for the columns `x` and `y` we have to always extract a single value out\nof `extracted_args`.\nBut with the columns `just` and `name` we need to extract the whole vector.\nAlso, we have to adjust the names to ensure that they are unique.\n\nIn this blog post, we will get the tedious stuff out of the way with the following helper functions.\nFeel free to ignore them, if you only care about the general idea.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\n## Write function that does splitting for each rectangle\n## Found no suitable purrr function that works in my case\nextract_value <- function(list, arg, rect) {\n  x <- list[[arg]]\n  # name and just need do be treated different\n  # In all cases just pick the i-th entry of list[[arg]]\n  if (!(arg %in% c('name', 'just'))) return(x[rect])\n  \n  ## There is only one name, so extract that and modify id\n  if (arg == 'name') {\n    return(paste0(x,  rect))\n  }\n  \n  # 'just' is two part vector and should always be the same\n  if (arg == 'just') return(x)\n}\n\nsplit_my_list <- function(list, n_rects) {\n  combinations <- tibble(\n    rect = 1:n_rects,\n    arg = list(names(list))\n  ) %>% \n    unnest(cols = c(arg)) \n  \n  flattened_list <- combinations %>% \n    pmap(~extract_value(list, ..2, ..1))\n  \n  names(flattened_list) <- combinations$arg\n  split(flattened_list, combinations$rect)\n}\n```\n:::\n\n\nFinally, we can split `extracted_args` into sub-lists. \nEach of these is then used to call \n`grid::roundrectGrob()` with `do.call()`.\nThen, we have to replace the same part in our list `grobs` as we did before.\nHowever, since we have multiple grobs now that need to be put into a single location.\nTherefore, we have to bundle the grobs into one object.\nThis is done via `grid::grobTree()` and `do.call()`.\n\n\n::: {.cell fig.showtext='true'}\n\n```{.r .cell-code}\nlist_of_arglists <-  split_my_list(extracted_args, n_rects)\nlist_of_grobs <- map(list_of_arglists, ~do.call(grid::roundrectGrob, .)) \n\n# Build new list of grobs by replacing one part in old list\ngrobs_new <- grobs\n\n# save one list argument into children[3]\ngrobs_new$children[3] <- do.call(grid::grobTree, list_of_grobs) %>% list()\nl_new <- l\nl_new$grobs[[6]] <- grobs_new\n\n# Draw Plot\ngrid::grid.newpage()\ngrid::grid.draw(l_new)\n```\n\n::: {.cell-output-display}\n![](11_rounded_rectangles_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\n## Conclusion\n\nWoooow!\nMarvel at our glorious rounded rectangles!\nThanks to our excellent programming skills we made it through the grob jungle.\nIn practice, it is probably easier to use `geom_chicklet()`.\nBut still, this was a somewhat fun exercise and helped to demystify grobs (at least to some extend).\n\nThat's it for today.\nIf you've made it this far, then you already know that you should follow me on [Twitter](https://twitter.com/rappa753) and/or subscribe to my [RSS feed](https://albert-rapp.de/blog.xml). \nSo, I expect you to be here next time.\nThere's no way out anymore.\nSo long!\n",
    "supporting": [
      "11_rounded_rectangles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
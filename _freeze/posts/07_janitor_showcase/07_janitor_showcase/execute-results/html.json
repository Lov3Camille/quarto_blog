{
  "hash": "b9e6ab6510b23e75024a3aeda5e5b0d5",
  "result": {
    "markdown": "---\ntitle: 'Showcasing the janitor package'\ndate: '2022-01-12'\ncategories: []\ndescription: \"I demonstrate a couple of functions from the janitor package I find quite useful\"\nexecute: \n  message: false\n  warning: false\n  collapse: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\nThe `janitor` package contains only a little number of functions but nevertheless\nit is surprisingly convenient.\nI never really fully appreciated its functionality until I took a look into the documentation.\nOf course, other packages can achieve the same thing too but `janitor` makes\na lot of tasks easy.\nThus, here is a little showcase.\nIf you prefer a video version, you can find this blog post on [YouTube](https://youtu.be/AKPvlNWZBEQ).\n\n## Clean column names\n\nAs everyone working with data knows, data sets rarely come in a clean format.\nOften, the necessary cleaning process already starts with the column names.\nHere, take this data set from TidyTuesday, week 41.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnurses <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-10-05/nurses.csv')\nnames(nurses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"State\"                                          \n [2] \"Year\"                                           \n [3] \"Total Employed RN\"                              \n [4] \"Employed Standard Error (%)\"                    \n [5] \"Hourly Wage Avg\"                                \n [6] \"Hourly Wage Median\"                             \n [7] \"Annual Salary Avg\"                              \n [8] \"Annual Salary Median\"                           \n [9] \"Wage/Salary standard error (%)\"                 \n[10] \"Hourly 10th Percentile\"                         \n[11] \"Hourly 25th Percentile\"                         \n[12] \"Hourly 75th Percentile\"                         \n[13] \"Hourly 90th Percentile\"                         \n[14] \"Annual 10th Percentile\"                         \n[15] \"Annual 25th Percentile\"                         \n[16] \"Annual 75th Percentile\"                         \n[17] \"Annual 90th Percentile\"                         \n[18] \"Location Quotient\"                              \n[19] \"Total Employed (National)_Aggregate\"            \n[20] \"Total Employed (Healthcare, National)_Aggregate\"\n[21] \"Total Employed (Healthcare, State)_Aggregate\"   \n[22] \"Yearly Total Employed (State)_Aggregate\"        \n```\n:::\n:::\n\n\nThese column names are intuitively easy to understand but not necessarily easy to process\nby code as there are white spaces and other special characters.\nTherefore, I accompany most data input by `clean_names()` from the `janitor` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\nlibrary(dplyr) # load for pipe %>%  and later wrangling\nnames(nurses %>% clean_names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"state\"                                       \n [2] \"year\"                                        \n [3] \"total_employed_rn\"                           \n [4] \"employed_standard_error_percent\"             \n [5] \"hourly_wage_avg\"                             \n [6] \"hourly_wage_median\"                          \n [7] \"annual_salary_avg\"                           \n [8] \"annual_salary_median\"                        \n [9] \"wage_salary_standard_error_percent\"          \n[10] \"hourly_10th_percentile\"                      \n[11] \"hourly_25th_percentile\"                      \n[12] \"hourly_75th_percentile\"                      \n[13] \"hourly_90th_percentile\"                      \n[14] \"annual_10th_percentile\"                      \n[15] \"annual_25th_percentile\"                      \n[16] \"annual_75th_percentile\"                      \n[17] \"annual_90th_percentile\"                      \n[18] \"location_quotient\"                           \n[19] \"total_employed_national_aggregate\"           \n[20] \"total_employed_healthcare_national_aggregate\"\n[21] \"total_employed_healthcare_state_aggregate\"   \n[22] \"yearly_total_employed_state_aggregate\"       \n```\n:::\n:::\n\n\nDid you see what happened?\nWhite spaces were converted to `_` and parantheses were removed.\nEven the `%` signs were converted to `percent`.\nNow, these labels are easy to understand AND process by code.\nThis does not mean that you are finished cleaning but at least now the columns\nare more accessible.\n\n## Remove empty and or constant columns and rows\n\nData sets come with empty or superfluous rows or columns are not a rare sighting. \nThis is especially true if you work with Excel files because there will be a lot of empty\ncells.\nTake a look at the dirty Excel data set from janitor's [GitHub page](https://github.com/sfirke/janitor/blob/main/dirty_data.xlsx).\nIt looks like this when you open it with Excel.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](dirty_data.PNG){width=751}\n:::\n:::\n\n\nTaking a look just at this picture we may notice a couple of things.\n\n- First, [Jason Bourne](https://en.wikipedia.org/wiki/Jason_Bourne) is teaching at a school. \nI guess being a trained assassin qualifies him to teach physical education.\nAlso - and this is just a hunch - undercover work likely earned him his \"Theater\" certification.\n\n- Second, the header above the actual table will be annoying, so we must skip the first line\nwhen we read the data set.\n\n- Third, the column names are not ideal but we know how to deal with that by now.\n\n- Fourth, there are empty rows and columns we can get rid of.\n\n- Fifth, there is a column that contains only 'YES'.\nTherefore it contains no information at all and can be removed.\n\nSo, let us read and clean the data.\nThe `janitor` package will help us with `remove_empty()` and `remove_constant()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxl_file <- readxl::read_excel('dirty_data.xlsx', skip = 1) %>% \n  clean_names() %>%\n  remove_empty() %>% \n  remove_constant()\nxl_file\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 9\n   first_name   last_n…¹ emplo…² subject hire_…³ perce…⁴ full_…⁵ certi…⁶ certi…⁷\n   <chr>        <chr>    <chr>   <chr>     <dbl>   <dbl> <chr>   <chr>   <chr>  \n 1 Jason        Bourne   Teacher PE        39690    0.75 Yes     Physic… Theater\n 2 Jason        Bourne   Teacher Drafti…   43479    0.25 Yes     Physic… Theater\n 3 Alicia       Keys     Teacher Music     37118    1    Yes     Instr.… Vocal …\n 4 Ada          Lovelace Teacher <NA>      38572    1    Yes     PENDING Comput…\n 5 Desus        Nice     Admini… Dean      42791    1    Yes     PENDING <NA>   \n 6 Chien-Shiung Wu       Teacher Physics   11037    0.5  Yes     Scienc… Physics\n 7 Chien-Shiung Wu       Teacher Chemis…   11037    0.5  Yes     Scienc… Physics\n 8 James        Joyce    Teacher English   36423    0.5  No      <NA>    Englis…\n 9 Hedy         Lamarr   Teacher Science   27919    0.5  No      PENDING <NA>   \n10 Carlos       Boozer   Coach   Basket…   42221   NA    No      Physic… <NA>   \n11 Young        Boozer   Coach   <NA>      34700   NA    No      <NA>    Politi…\n12 Micheal      Larsen   Teacher English   40071    0.8  No      Vocal … English\n# … with abbreviated variable names ¹​last_name, ²​employee_status, ³​hire_date,\n#   ⁴​percent_allocated, ⁵​full_time, ⁶​certification_9, ⁷​certification_10\n```\n:::\n:::\n\n\nHere, `remove_empty()` defaulted to remove, both, rows and colums.\nIf we wish, we can change that by setting e.g. `which = 'rows'`.\n\nNow, we may also want to see the `hire_data` in a sensible format.\nFor example, in this dirty data set, Jason Bourne was hired on `39690`.\nLuckily, our `janitor` can make sense of it all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxl_file %>% \n  mutate(hire_date = excel_numeric_to_date(hire_date))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 9\n   first_name last_…¹ emplo…² subject hire_date  perce…³ full_…⁴ certi…⁵ certi…⁶\n   <chr>      <chr>   <chr>   <chr>   <date>       <dbl> <chr>   <chr>   <chr>  \n 1 Jason      Bourne  Teacher PE      2008-08-30    0.75 Yes     Physic… Theater\n 2 Jason      Bourne  Teacher Drafti… 2019-01-14    0.25 Yes     Physic… Theater\n 3 Alicia     Keys    Teacher Music   2001-08-15    1    Yes     Instr.… Vocal …\n 4 Ada        Lovela… Teacher <NA>    2005-08-08    1    Yes     PENDING Comput…\n 5 Desus      Nice    Admini… Dean    2017-02-25    1    Yes     PENDING <NA>   \n 6 Chien-Shi… Wu      Teacher Physics 1930-03-20    0.5  Yes     Scienc… Physics\n 7 Chien-Shi… Wu      Teacher Chemis… 1930-03-20    0.5  Yes     Scienc… Physics\n 8 James      Joyce   Teacher English 1999-09-20    0.5  No      <NA>    Englis…\n 9 Hedy       Lamarr  Teacher Science 1976-06-08    0.5  No      PENDING <NA>   \n10 Carlos     Boozer  Coach   Basket… 2015-08-05   NA    No      Physic… <NA>   \n11 Young      Boozer  Coach   <NA>    1995-01-01   NA    No      <NA>    Politi…\n12 Micheal    Larsen  Teacher English 2009-09-15    0.8  No      Vocal … English\n# … with abbreviated variable names ¹​last_name, ²​employee_status,\n#   ³​percent_allocated, ⁴​full_time, ⁵​certification_9, ⁶​certification_10\n```\n:::\n:::\n\n\n## Rounding \n\nTo my ~~surprise~~ shock, R uses some unexpected rounding rule.\nIn my world, whenever a number ends in `.5`, standard rounding would round up.\nApparently, R uses something called *banker's rounding* that in these cases \nrounds towards the next *even* number.\nTake a look.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(seq(0.5, 4.5, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 2 2 4 4\n```\n:::\n:::\n\n\nI would expect that the rounded vector contains the integers from one to five.\nThankfully, `janitor` offers a convenient rounding function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_half_up(seq(0.5, 4.5, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nOk, so that gives us a new function for rounding towards integers.\nBut what is really convenient is that `janitor` can `round_to_fraction`s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_to_fraction(seq(0.5, 2.0, 0.13), denominator = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.50 0.75 0.75 1.00 1.00 1.25 1.25 1.50 1.50 1.75 1.75 2.00\n```\n:::\n:::\n\n\nHere, I rounded the numbers to the next quarters (`denominator = 4`) but of course\nany fraction is possible. \nYou can now live the dream of rounding towards arbitrary fractions.\n\n\n## Find matches in multiple characteristics\n\nIn my opinion, the `get_dupes()` function is really powerful.\nIt allows us to find \"similar\" observations in a data set based on certain characteristics.\nFor example, the `starwars` data set from `dplyr`  contains a lot of information \non characters from the Star Wars movies.\nPossibly, we want to find out which characters are similar w.r.t. to certain traits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstarwars %>% \n  get_dupes(eye_color, hair_color, skin_color, sex, homeworld) %>% \n  select(1:8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 8\n  eye_color hair_color skin_color sex    homeworld dupe_count name        height\n  <chr>     <chr>      <chr>      <chr>  <chr>          <int> <chr>        <int>\n1 blue      black      yellow     female Mirial             2 Luminara U…    170\n2 blue      black      yellow     female Mirial             2 Barriss Of…    166\n3 blue      blond      fair       male   Tatooine           2 Luke Skywa…    172\n4 blue      blond      fair       male   Tatooine           2 Anakin Sky…    188\n5 brown     brown      light      female Naboo              3 Cordé          157\n6 brown     brown      light      female Naboo              3 Dormé          165\n7 brown     brown      light      female Naboo              3 Padmé Amid…    165\n```\n:::\n:::\n\n\nSo, Luke and Anakin Skywalker are similar to one another. \nWho would have thought that.\nSadly, I don't enough about Star Wars to know whether the other matches are similarly \n\"surprising\".\nIn any case, the point here is that we can easily find matches according to \narbitrarily many characteristics.\nConveniently, these characteristics are the first columns of the new output and \nwe get a `dupe_count`.\n\n\nAlright, this concludes our little showcase.\nIn the `janitor` package, there is another set of `tabyl()` functions. \nThese are meant to improve base R's `table()` functions. \nSince I rarely use that function I did not include it but if you use `table()` frequently, \nthen you should definitely [check out tabyl()](http://sfirke.github.io/janitor/articles/tabyls.html).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
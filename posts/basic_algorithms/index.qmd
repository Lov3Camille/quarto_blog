---
title: '基础算法模板'
date: '2022-11-05'
categories: ['cpp', 'algorithms']
description: ' '
execute: 
  message: false
  warning: false
editor_options: 
  chunk_output_type: console
---

# 快速排序
```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];

void quick_sort(int q[], int l, int r) {
    if (l >= r) {
        return;
    }

    int x = q[l], i = l - 1, j = r + 1;

    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) {
            swap(q[i], q[j]);
        }
    }

    quick_sort(q, l, j); 
    quick_sort(q, j + 1, r);
}

int main() {
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &q[i]);
    }

    quick_sort(q, 0, n - 1);

    for (int j = 0; j < n; j++) {
        printf("%d", q[j]);
    };
}
```

# 归并排序
```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int n;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r) {
    if (l >= r) return;

    int mid = l + r >> 1;

    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        if (q[i] > q[j]) tmp[k++] = q[j++];
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];

    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);

    merge_sort(q, 0, n - 1);

    for (int j = 0; j < n; j++) printf("%d", q[j]);
}
```

# 二分算法

## 整数二分

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 -1 -1。

```cpp
#include <iostream>

using namespace std;

const int N = 100000;

int n, m;
int q[N];

int main() {
    scanf("%d%d", &n, &m);

    for (int i = 0; i < n; i++) scanf("%d", &q[i]);

    while (m--) {
        int x;
        scanf("%d", &x);

        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (x <= q[mid]) r = mid; // fetch the left border
            else l = mid + 1; 
        }
        if (q[l] != x) cout << "-1 -1" << endl;
        else {
            cout << l << " ";

            l = 0, r = n - 1;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (x >= q[mid]) l = mid; // fetch the right border
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
}
```

## 浮点数二分

求一个数的平方根。

```cpp
#include <iostream>

using namespace std;

int main() {
    double x;
    cin >> x;

    double l = 0, r = x;

    while (r - l > 1e-8) {
        double mid = (l + r) / 2;
        if (mid * mid > x) r = mid;
        else l = mid; 
    }

    printf("%f\n", l);
}
```

# 高精度加法
```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e6 + 10;

vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    
    int t = 0;

    for (int i = 0; i < A.size() || i < B.size(); i++) {
        if (i < A.size()) t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t = t / 10;
    }
    if (t) C.push_back(t);
    return C;
}

int main() {
    string a, b;
    vector<int> A, B;
    cin >> a >> b;

    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); // convert char to int
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');

    vector<int> C = add(A, B);

    for (int i = C.size() - 1; i >= 0; i--) printf("%d", C[i]);

    return 0;
}
```
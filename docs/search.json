[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Love Camille",
    "section": "",
    "text": "All blog posts\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n<克拉拉与太阳>读后感\n\n\n\n\n\n\n\nreading\n\n\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\nLeetCode 周赛记录\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n2 min\n\n\n\n\n\n\n\n\nLeetCode 刷题记录\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\n11 min\n\n\n\n\n\n\n\n\nDRX夺冠有感\n\n\n\n\n\n\n\nlife\n\n\n\n\n\n\n\n\n\n\n\nNov 7, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\n基础算法模板\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\nCMU 15-213 Lab0\n\n\n\n\n\n\n\nc\n\n\ncmu_15_213\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\n实现一个简易的C++ String类\n\n\n\n\n\n\n\ncpp\n\n\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\n实现一个简易Shell\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nSep 12, 2022\n\n\n6 min\n\n\n\n\n\n\n\n\n这几年\n\n\n\n\n\n\n\nlife\n\n\n\n\n离开深圳前一些想说的话\n\n\n\n\n\n\nJul 4, 2022\n\n\n0 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Love Camille",
    "section": "",
    "text": "Hi, I’m Lov3 Camille.\nYou can find me on Twitter or GitHub. Feel free to reach out to me via mail and subscribe to my email newsletter."
  },
  {
    "objectID": "posts/camille_shell/index.html",
    "href": "posts/camille_shell/index.html",
    "title": "实现一个简易Shell",
    "section": "",
    "text": "根据Stephen Brennan的Tutorial实现的一个简易的Shell.\n\n\n一个Shell的生命周期包括三个基本部分：\n\n初始化： Shell读取并执行配置文件；\n转译： Shell读取标准输入（交互式输入或者文件）并执行；\n\n终止： 命令执行完毕，Shell执行结束命令，释放内存并终止；\n\n因此， 我们可以得到主函数的基本结构：\nint main() {\n  ls_loop();\n  return EXIT_SUCCESS;\n}\n\n\n\n循环分三步： - 读： 读取标准输入的指令； - 解析： 将输入的命令字符串分割成程序和参数； - 执行： 运行解析好的命令。\n这样我们可以得到循环体内的基本逻辑：\nvoid lsh_loop(void)\n{\n  char *line;\n  char **args;\n  int status;\n\n  do {\n    printf(\"> \");\n    line = lsh_read_line();\n    args = lsh_split_line(line);\n    status = lsh_execute(args);\n\n    free(line);\n    free(args);\n  } while (status);\n}\n\n\n\n为什么需要内置命令呢？以cd命令为例，它的作用是改变目录，那么如果Shell将该命令交给子进程去执行，那么 就只能改变子进程的目录，对于用户来说等于什么都没做，这显然不是我们想要的结果。所以需要将此类命令作为内置命令实现。\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define LSH_RL_BUF_SIZE 1024\nchar *lsh_read_line_old(void) {\n  int buf_size = LSH_RL_BUF_SIZE;\n  int position = 0;\n  char *buffer = malloc(sizeof(char) * buf_size);\n  int c;\n\n  if (!buffer) {\n    fprintf(stderr, \"lsh: allocation error\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  while (1) {\n    // Read a character\n    c = getchar();\n\n    // if we hit EOF, replace it with a null character and return\n    if (c == EOF || c == '\\n') {\n        buffer[position] = '\\0';\n        return buffer;\n    } else {\n        buffer[position] = c;\n    }\n    position++;\n\n    // if we have exceeded the buffer, reallocate\n    if (position >= buf_size) {\n        buf_size += LSH_RL_BUF_SIZE;\n        buffer = realloc(buffer, buf_size);\n        if (!buffer) {\n            fprintf(stderr, \"lsh: allocation error\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n  }\n}\n\nchar *lsh_read_line_new(void) {\n    char* line = NULL;\n    ssize_t buf_size = 0; // have getline allocate a buffer for us\n\n    if (getline(&line, &buf_size, stdin) == -1) {\n        if (feof(stdin)) {\n            exit(EXIT_SUCCESS); // we received an EOF\n        } else {\n            perror(\"readline\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    return line;\n}\n\n#define LSH_TOK_BUF_SIZE 64\n#define LSH_TOK_DELIM \" \\t\\r\\n\\a\"\nchar **lsh_split_line(char *line) {\n    int buf_size = LSH_TOK_BUF_SIZE, position = 0;\n    char **tokens = malloc(buf_size * sizeof(char*));\n    char *token;\n\n    if (!tokens) {\n        fprintf(stderr, \"lsh: allocation error\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    token = strtok(line, LSH_TOK_DELIM);\n    while (token != NULL) {\n        tokens[position] = token;\n        position++;\n\n        if (position >= buf_size) {\n            buf_size += LSH_RL_BUF_SIZE;\n            tokens = realloc(tokens, buf_size * sizeof(char*));\n            if (!tokens) {\n                fprintf(stderr, \"lsh: allocation error\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        token = strtok(NULL, LSH_TOK_DELIM);\n    }\n    tokens[position] = NULL;\n    return tokens;\n}\n\nint lsh_launch(char** args) {\n    pid_t pid, wpid;\n    int status;\n\n    pid = fork();\n    if (pid == 0) {\n        // Child process\n        if (execvp(args[0], args) == -1) {\n            perror(\"lsh child process execute error!\");\n        }\n        exit(EXIT_FAILURE);\n    } else if (pid < 0) {\n        // Error in forking\n        perror(\"lsh fork error!\");\n    } else {\n        // Parent process\n        do {\n            wpid = waitpid(pid, &status, WUNTRACED);\n        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n    }\n    return 1;\n}\n\n/*\n * Function declaration for builtin shell commands:\n */\nint lsh_cd(char **args);\nint lsh_help(char **args);\nint lsh_exit(char **args);\n\n/*\n * List of builtin commands, followed by their corresponding functions.\n */\nchar* builtin_str[] = {\n        \"cd\",\n        \"help\",\n        \"exit\"\n};\n\nint (*builtin_func[]) (char**) = {\n        &lsh_cd,\n        &lsh_help,\n        &lsh_exit\n};\n\nint lsh_num_builtins() {\n    return sizeof(builtin_str) / sizeof(char*);\n}\n\n/*\n * Builtin function implementation\n */\nint lsh_cd(char** args) {\n    if (args[1] == NULL) {\n        fprintf(stderr, \"lsh: expected argument to \\\"cd\\\"\\n\");\n    } else {\n        if (chdir(args[1]) != 0) {\n            perror(\"lsh change directory error!\");\n        }\n    }\n    return 1;\n}\n\nint lsh_help(char** args) {\n    int i;\n    printf(\"LSH from scratch\\n\");\n    printf(\"Type program names and arguments, and hit enter.\\n\");\n    printf(\"The following are built in:\\n\");\n\n    for (i = 0; i < lsh_num_builtins(); i++) {\n        printf(\" %s\\n\", builtin_str[i]);\n    }\n\n    printf(\"Use the man command for information and other programs.\\n\");\n    return 1;\n}\n\nint lsh_exit(char** args) {\n    return 0;\n}\n\nint lsh_execute(char **args) {\n    int i;\n    if (args[0] == NULL) {\n        // An empty command was entered.\n        return 1;\n    }\n    // Find the matched builtin command and execute it\n    for (i = 0; i < lsh_num_builtins(); i++) {\n        if (strcmp(args[0], builtin_str[i]) == 0) {\n            return (*builtin_func[i])(args);\n        }\n    }\n    return lsh_launch(args);\n}\n\nvoid ls_loop(void) {\n    char *line;\n    char **args;\n    int status;\n\n    do {\n        printf(\"> \");\n        line = lsh_read_line_new();\n        args = lsh_split_line(line);\n        status = lsh_execute(args);\n    } while (status);\n}\n\nint main() {\n  ls_loop();\n  return EXIT_SUCCESS;\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html",
    "href": "posts/basic_algorithms/index.html",
    "title": "基础算法模板",
    "section": "",
    "text": "#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint q[N];\n\nvoid quick_sort(int q[], int l, int r) {\n    if (l >= r) {\n        return;\n    }\n\n    int x = q[l], i = l - 1, j = r + 1;\n\n    while (i < j) {\n        do i++; while (q[i] < x);\n        do j--; while (q[j] > x);\n        if (i < j) {\n            swap(q[i], q[j]);\n        }\n    }\n\n    quick_sort(q, l, j); \n    quick_sort(q, j + 1, r);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &q[i]);\n    }\n\n    quick_sort(q, 0, n - 1);\n\n    for (int j = 0; j < n; j++) {\n        printf(\"%d\", q[j]);\n    };\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#整数二分",
    "href": "posts/basic_algorithms/index.html#整数二分",
    "title": "基础算法模板",
    "section": "整数二分",
    "text": "整数二分\n给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。\n对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。\n如果数组中不存在该元素，则返回 -1 -1。\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100000;\n\nint n, m;\nint q[N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n\n    for (int i = 0; i < n; i++) scanf(\"%d\", &q[i]);\n\n    while (m--) {\n        int x;\n        scanf(\"%d\", &x);\n\n        int l = 0, r = n - 1;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (x <= q[mid]) r = mid; // fetch the left border\n            else l = mid + 1; \n        }\n        if (q[l] != x) cout << \"-1 -1\" << endl;\n        else {\n            cout << l << \" \";\n\n            l = 0, r = n - 1;\n            while (l < r) {\n                int mid = l + r + 1 >> 1;\n                if (x >= q[mid]) l = mid; // fetch the right border\n                else r = mid - 1;\n            }\n            cout << l << endl;\n        }\n    }\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#浮点数二分",
    "href": "posts/basic_algorithms/index.html#浮点数二分",
    "title": "基础算法模板",
    "section": "浮点数二分",
    "text": "浮点数二分\n求一个数的平方根。\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    double x;\n    cin >> x;\n\n    double l = 0, r = x;\n\n    while (r - l > 1e-8) {\n        double mid = (l + r) / 2;\n        if (mid * mid > x) r = mid;\n        else l = mid; \n    }\n\n    printf(\"%f\\n\", l);\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#加法",
    "href": "posts/basic_algorithms/index.html#加法",
    "title": "基础算法模板",
    "section": "加法",
    "text": "加法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nvector<int> add(vector<int> &A, vector<int> &B) {\n    vector<int> C;\n    \n    int t = 0;\n\n    for (int i = 0; i < A.size() || i < B.size(); i++) {\n        if (i < A.size()) t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t = t / 10;\n    }\n    if (t) C.push_back(t);\n    return C;\n}\n\nint main() {\n    string a, b;\n    vector<int> A, B;\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); // convert char to int\n    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');\n\n    vector<int> C = add(A, B);\n\n    for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#减法",
    "href": "posts/basic_algorithms/index.html#减法",
    "title": "基础算法模板",
    "section": "减法",
    "text": "减法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\n// compare A and B\nbool cmp(vector<int> &A, vector<int> &B) {\n    if (A.size() != B.size()) return A.size() > B.size();\n    for (int i = 0; i < A.size(); i++) {\n        if (A[i] != B[i]) return A[i] > B[i];\n    }\n    return true;\n}\n\nvector<int> sub(vector<int> &A, vector<int> &B) {\n    vector<int> C;\n    for (int i = 0, t = 0; i < A.size(); i++) {\n        t = A[i] - t;\n        if (i < B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t < 0) t = 1;\n        else t = 0;\n    }\n    while (C.size() > 1 && C.back() == 0) C.pop_back(); // remember to delete redundant zero\n    return C;\n}\n\nint main() {\n    string a, b;\n    vector<int> A, B;\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');\n\n    if (cmp(A, B)) {\n        auto C = sub(A, B);\n        for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n    } else {\n        auto C = sub(B, A);\n        printf(\"-\");\n        for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n    }\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#乘法",
    "href": "posts/basic_algorithms/index.html#乘法",
    "title": "基础算法模板",
    "section": "乘法",
    "text": "乘法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> mul(vector<int> &A, int b) {\n    int t = 0;\n    vector<int> C;\n    for (int i = 0; i < A.size() || t; i++) {\n        if (i < A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    return C;\n}\n\nint main() {\n    string a;\n    vector<int> A;\n    int b;\n\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n\n    auto C = mul(A, b);\n\n    if (C[C.size() - 1] == 0) cout << 0 << endl;\n\n    else for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#除法",
    "href": "posts/basic_algorithms/index.html#除法",
    "title": "基础算法模板",
    "section": "除法",
    "text": "除法\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> div(vector<int> &A, int b, int &r) {\n    vector<int> C;\n    r = 0;\n\n    for (int i = A.size(); i >= 0; i--) {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n\n    reverse(C.begin(), C.end());\n\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n\n    return C;\n}\n\nint main() {\n    string a;\n    int b;\n    \n    cin >> a >> b;\n\n    vector<int> A;\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n\n    int r;\n    auto C = div(A, b, r);\n\n    for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n\n    cout << endl << r << endl;\n}"
  },
  {
    "objectID": "posts/cmu_15-213_lab0/index.html",
    "href": "posts/cmu_15-213_lab0/index.html",
    "title": "CMU 15-213 Lab0",
    "section": "",
    "text": "利用C语言实现一个队列的基本功能，包括：\n\n创建队列\n销毁队列\n头部入队\n尾部入队\n头部出队\n获取队列长度\n反转队列\n\n核心在于每次对队列操作前都要考虑是否为空的情况，保证代码的鲁棒性。\n\n\n#include <stdbool.h>\n#include <stddef.h>\n\n/* element struct in queue */\ntypedef struct list_ele {\n    char *value;\n    struct list_ele *next;\n} list_ele_t;\n\ntypedef struct {\n    list_ele_t *head;\n    list_ele_t *tail;\n    int size; // use the above two variable to record the size of the queue to avoid traversal\n} queue_t;\n\n/* Create empty queue. */\nqueue_t *queue_new(void);\n\n/* Free ALL storage used by queue. */\nvoid queue_free(queue_t *q);\n\n/* Attempt to insert element at head of queue. */\nbool queue_insert_head(queue_t *q, const char *s);\n\n/* Attempt to insert element at tail of queue. */\nbool queue_insert_tail(queue_t *q, const char *s);\n\n/* Attempt to remove element from head of queue. */\nbool queue_remove_head(queue_t *q, char *sp, size_t bufsize);\n\n/* Return number of elements in queue. */\nsize_t queue_size(queue_t *q);\n\n/* Reverse elements in queue */\nvoid queue_reverse(queue_t *q);\n可以看到，在源文件的基础上，新增了尾节点和队列大小两个属性，当然也可以不加，但如果没有这两个变量，计算队列大小或者进行尾部入队操作的时间复杂度就不是常量了，而是线性增长的。\n下面我们具体看每个函数的实现。\n\n\n\n/**\n * @brief Allocates a new queue\n * @return The new queue, or NULL if memory allocation failed\n */\nqueue_t *queue_new(void) {\n    queue_t *q = malloc(sizeof(queue_t));\n    /* What if malloc returned NULL? */\n    if (q == NULL) {\n        return NULL;\n    } else {\n        q->head = NULL;\n        q->tail = NULL;\n        q->size = 0;\n        return q;\n    }\n}\n这一步没什么问题，主要就是分配队列空间并初始化队列的各个属性。\n\n\n\n/**\n * @brief Frees all memory used by a queue\n * @param[in] q The queue to free\n */\nvoid queue_free(queue_t *q) {\n    /* How about freeing the list elements and the strings? */\n    /* Free queue structure */\n    if (q == NULL) {\n        return;\n    } else {\n        list_ele_t *tmp;\n        while (q->head != NULL) {\n            tmp = q->head;\n            q->head = q->head->next;\n            free(tmp->value); // free element's value\n            free(tmp) // free element itself\n        }\n    }\n    free(q); // free queue\n}\n如上所述，判断完队列是否为空，还需要判断队列的属性是否为空。\n\n\n\n/**\n * @brief Attempts to insert an element at head of a queue\n *\n * This function explicitly allocates space to create a copy of `s`.\n * The inserted element points to a copy of `s`, instead of `s` itself.\n *\n * @param[in] q The queue to insert into\n * @param[in] s String to be copied and inserted into the queue\n *\n * @return true if insertion was successful\n * @return false if q is NULL, or memory allocation failed\n */\nbool queue_insert_head(queue_t *q, const char *s) {\n    list_ele_t *newh;\n    /* What should you do if the q is NULL? */\n    if (q == NULL) {\n        return false;\n    }\n    /* Don't forget to allocate space for the string and copy it */\n    /* What if either call to malloc returns NULL? */\n    newh = malloc(sizeof(list_ele_t));\n    if (newh == NULL) {\n        return false;\n    } else {\n        newh->value = malloc(sizeof(char) * (strlen(s) + 1));\n        if (newh->value == NULL) {\n            free(newh); // must free the space if malloc failed\n            return false;\n        } else {\n            strcpy(newh->value, s);\n            newh->next = q->head;\n            q->head = newh;\n\n            if (q->tail == NULL) {\n                q->tail = newh;\n            }\n            ++q->size;\n            return true;\n        }\n    }\n}\n除了判断队列及队列元素是否为空，还要判断malloc()是否成功， 正常来讲，内存分配成功的话，会返回一个可以指向任意类型的指针，但该指针必须通过free()或者realloc()回收。 如果分配失败了，会返回一个空指针，我们需要对其进行判断。\n\n\n\n/**\n * @brief Attempts to insert an element at tail of a queue\n *\n * This function explicitly allocates space to create a copy of `s`.\n * The inserted element points to a copy of `s`, instead of `s` itself.\n *\n * @param[in] q The queue to insert into\n * @param[in] s String to be copied and inserted into the queue\n *\n * @return true if insertion was successful\n * @return false if q is NULL, or memory allocation failed\n */\nbool queue_insert_tail(queue_t *q, const char *s) {\n    /* You need to write the complete code for this function */\n    /* Remember: It should operate in O(1) time */\n    list_ele_t *newt;\n    /* What should you do if the q is NULL? */\n    if (q == NULL) {\n        return false;\n    }\n    /* Don't forget to allocate space for the string and copy it */\n    /* What if either call to malloc returns NULL? */\n    newt = malloc(sizeof(list_ele_t));\n    if (newt == NULL) {\n        return false;\n    } else {\n        newt->value = malloc(sizeof(char) * (strlen(s) + 1));\n        if (newt->value == NULL) {\n            free(newt);\n            return false;\n        } else {\n            strcpy(newt->value, s);\n            newt->next = NULL;\n\n            if (q->tail != NULL) {\n                q->tail->next = newt;\n                q->tail = newt;\n            } else {\n                q->head = newt;\n                q->tail = newt;\n            }\n            ++q->size;\n            return true;\n        }\n    }\n}\n这一步和头部入队类似，不同点在于需要对尾节点是否存在进行判断，而头部入队时是不需要判断头节点是否存在的，因为必然要进行重新分配且不需要对其执行查找下一个节点的操作。\n\n\n\n/**\n * @brief Attempts to remove an element from head of a queue\n *\n * If removal succeeds, this function frees all memory used by the\n * removed list element and its string value before returning.\n *\n * If removal succeeds and `buf` is non-NULL, this function copies up to\n * `bufsize - 1` characters from the removed string into `buf`, and writes\n * a null terminator '\\0' after the copied string.\n *\n * @param[in]  q       The queue to remove from\n * @param[out] buf     Output buffer to write a string value into\n * @param[in]  bufsize Size of the buffer `buf` points to\n *\n * @return true if removal succeeded\n * @return false if q is NULL or empty\n */\nbool queue_remove_head(queue_t *q, char *buf, size_t bufsize) {\n    if (q == NULL) {\n        return false;\n    }\n    if (q->head == NULL) {\n        return false;\n    } else {\n        list_ele_t *temp = q->head;\n        q->head = q->head->next;\n        if (buf != NULL) {\n            strncpy(buf, temp->value, bufsize - 1);\n            buf[bufsize - 1] = '\\0';\n        }\n        free(temp->value);\n        free(temp);\n        --q->size;\n    }\n    return true;\n}\n这里注意一下strncpy的用法就好了，要保证buf是C-Style的字符数组。\n\n\n\n/**\n * @brief Returns the number of elements in a queue\n *\n * This function runs in O(1) time.\n *\n * @param[in] q The queue to examine\n *\n * @return the number of elements in the queue, or\n *         0 if q is NULL or empty\n */\nsize_t queue_size(queue_t *q) {\n    /* You need to write the code for this function */\n    /* Remember: It should operate in O(1) time */\n    if (q == NULL) {\n        return 0;\n    } else {\n        return q->size;\n    }\n}\n这没什么好说的，在前面执行入队、出队的时候不要忘记修改size的值就可以，这里只需要直接返回，而不需要通过遍历队列的方式去计算。\n\n\n\n/**\n * @brief Reverse the elements in a queue\n *\n * This function does not allocate or free any list elements, i.e. it does\n * not call malloc or free, including inside helper functions. Instead, it\n * rearranges the existing elements of the queue.\n *\n * @param[in] q The queue to reverse\n */\nvoid queue_reverse(queue_t *q) {\n    /* You need to write the code for this function */\n    if (q == NULL || q->head == NULL) {\n        return;\n    } else {\n        list_ele_t *oldHead = q->head;\n        list_ele_t *oldTail = q->tail;\n\n        list_ele_t *temp = q->head;\n        list_ele_t *prev = NULL;\n        list_ele_t *next = NULL;\n        while (temp != NULL) {\n            next = temp->next;\n            temp->next = prev;\n            prev = temp;\n            temp = next;\n        }\n        q->head = oldTail;\n        q->tail = oldHead;\n    }\n}\n经典的反转链表，这里就不赘述了。\n\n\n\n一共是提供了十五组测试用例，满分一百，包括了对各个函数及其性能的测试(测试尾部入队10000个元素)，还有鲁棒性测试（释放空队列的空间，从空队列中移除头部元素等），还是比较全面的。"
  },
  {
    "objectID": "posts/new_beginnings/index.html",
    "href": "posts/new_beginnings/index.html",
    "title": "这几年",
    "section": "",
    "text": "“有个阴天，没有下雨，但我到公司后还是和前台借了一把伞，过了几天准备下楼还伞的时候，外面却下起了大雨，而那天很多人都没伞。”"
  },
  {
    "objectID": "posts/new_beginnings/index.html#流水账",
    "href": "posts/new_beginnings/index.html#流水账",
    "title": "这几年",
    "section": "流水账",
    "text": "流水账\n2020年初拿到港中文offer，从上一家公司离职后，一直踌躇满志，找了很多关于如何学习计算机的资料，想着自己终于可以做自己喜欢的事情了。于是在闵行租了一个小屋子， 天天闷在里面学习、打游戏、抽烟、睡懒觉，日复一日。\n过了几个月，去了西安和女朋友呆一起，本来以为过不了多久就去香港了，结果疫情严重，全部改为网课，就这样一边上网课，一边试了下秋招，结果一律过不了初面。终于发现，学校教的和工作需要的其实并不完全一致。但不管怎样，虽说是上网课，也和几个同学相谈甚欢，学到了不少。\n就这样，直到十二月份，我才开始看一些培训班的视频，开着两倍速，不知道比刚开始抱着《JAVA核心技术》一个字一个字啃要快多少倍。很快，十二月底，拿到了腾讯的实习和华为的留学生秋招offer。\n在腾讯实习了几个月之后又去了阿里实习，后来秋招又拿了一些offer，最后在2021年底正式入职腾讯。\n再后来，从今年4月初开始，日子一直不好过，为了避免被裁或是为了缓解老板的焦虑，我们表演式加班，一天又一天。结果6月27号还是通知我被裁了，可笑的是，第二天又被通知有应届生保护政策留下了（事实上我早就想走了），最后经过一番协商，也给了些赔偿。现在发这篇博客的时候离我离职日期正好还剩一周。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#慎",
    "href": "posts/new_beginnings/index.html#慎",
    "title": "这几年",
    "section": "慎",
    "text": "慎\n我平时爱玩英雄联盟，也感谢腾讯每个月业务体验福利让我这个穷b摇身一变成了皮肤狗。但我现在爱玩这个游戏和刚开始玩它的理由已经有了很大不同。刚开始是因为大家都玩，军校里也没啥别的娱乐方式，去游戏里杀人排解烦闷罢了。现在我倒是会研究各个英雄的台词。虽说也是人编出来的，但多少给我点启发。\n就比如暮光之眼-慎，他有几句台词：\n\n“Tread carefully（要步步为营）”\n\n\n“A demonstration of superior judgement（您果然深思熟虑）”\n\n从去年实习开始，我就骑驴找马，再后来拒秋招offer的时候，我给的理由都是我去读博了，事实上我确实有考虑读博。然后今年四月份的某个加班到十点的晚上，我在回家的路上突然就决定去要回我去年的offer。\n无奈过程令人煎熬，一直到通知被裁后两周才最终敲定，这三个月滋味真不好受。但有时候想想我那装精神病三个月，期间一次没碰过电子产品的军校同学，大概也有异曲同工之妙吧。\n现在回想起来，慎这个英雄大概真的影响到了我，要时刻保持谨慎，要有全局思维。而我做这些决定的时候，并没有想太多，大概就类似于游戏里的肌肉记忆吧。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#ambition",
    "href": "posts/new_beginnings/index.html#ambition",
    "title": "这几年",
    "section": "Ambition",
    "text": "Ambition\n为什么会突然想到Ambition这个选手呢？因为我2017年退伍，病床上看S7的比赛，看EDG一万经济被翻盘，看EDG的粉丝在赛场外哭到呕吐。而那一年Ambition打败Faker，拿下了S7的冠军，我却考研失败。\n但回顾Ambition的职业生涯，2012年以中单成名，2013年被Faker单杀，开始走下坡路，那一年正好我进入科大。\n所以我觉得我的2017年过的并不失败，大概我心中住了一个Ambition吧。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#朋友",
    "href": "posts/new_beginnings/index.html#朋友",
    "title": "这几年",
    "section": "朋友",
    "text": "朋友\n我有几个同学，平时喜欢一起玩英雄联盟，喜欢四黑然后在快赢的时候点投降，喜欢一起住电竞酒店，喜欢抽着烟漫步在凌晨的淮海中路被人问要不要代驾（其实是需要代练），喜欢在KTV听渣威的《童话镇》、阿杰的《像我这样的人》、阿煊的《夏日寒风》却没钱点酒，喜欢找女陪玩结果发现大部分除了发嗲别的啥都不会。\n就这样过了几年，直到大家都没力气通宵，没力气抽烟，直到唯一一个打的很好的女陪玩也弃游了，直到大家都有了女朋友甚至老婆。\n我们最近一次共同经历的事已经不是英雄联盟了，居然是部队问我们要那多发的两个月津贴，大伙都不想给，于是支付了一杯奶茶钱当律师费，然后心满意足地发现自己当老赖的想法得到了律师的认可。\n但我还是会每天上游戏玩个一两把，看着右边黑乎乎的好友栏，看着只有一个亮起的ID，那个人叫“还在等她说晚安”。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#工作",
    "href": "posts/new_beginnings/index.html#工作",
    "title": "这几年",
    "section": "工作",
    "text": "工作\n算上实习，算上陆院那几个月，也工作了快四年了，期间兜兜转转，从南昌到上海，从上海到深圳，现在又回到上海，我一直嘲笑老婆工作不稳定，老是出差，但她都在同一个地方工作五年了，我却换了五个地方。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#未来",
    "href": "posts/new_beginnings/index.html#未来",
    "title": "这几年",
    "section": "未来",
    "text": "未来\n最近在重读古龙，后面计划写些读后感，希望能赚点钱买纸质书而不是网上下盗版，希望家里房子顺利盖好，希望家人和朋友身体健康、工作顺利。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html",
    "href": "posts/klara_and_the_sun/index.html",
    "title": "<克拉拉与太阳>读后感",
    "section": "",
    "text": "很久没写过读后感了，上次写应该还是在高中，从小学到高中读过很多书和期刊，也正是这些书塑造了我的一部分人格，所以我必须感谢这些书，以及给予我阅读条件的爸妈、外婆、老师。\n关于《克拉拉与太阳》这本书，从买回来到读完，花了快一年，深圳买来，上海读完，期间也换了工作，经历了似乎发生了很多事又似乎什么都没发生的2022年。\n至于我为什么花了一年才读完，相信现代人很能理解，因为手机和电脑已经占据了我们的工作与生活，重新拿起纸质书本就不容易。但仔细一想，其实每天读一些也能很快读完，说到底还是自己懒，但毕竟这是这几年第一本完整读完的纸质书，值得纪念一下。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#什么是克拉拉",
    "href": "posts/klara_and_the_sun/index.html#什么是克拉拉",
    "title": "<克拉拉与太阳>读后感",
    "section": "什么是克拉拉",
    "text": "什么是克拉拉\n克拉拉是一个专为陪伴儿童而设计的太阳能人工智能机器人，具有极高的观察、推理与共情能力。在石黑一雄的采访中，他有提到很关注甚至担忧人工智能的发展，但我个人认为人类要理解产生智力的机制这一关键因素才有可能生产出有共情能力的机器人，而我们离这一步还有很长的路要走。\n那么显然在书中人类社会已经具备了生产这类机器人的能力，并且还在不断升级，因为克拉拉并不是最新型号的那一批。而且从书的结尾也不难发现，这已经成了一条流水线，从生产到投入商店到折旧回收，已经不足为奇。还有一个很重要的点是这些机器人只会一心一意地为主人着想，百分之百利他。这一点从克拉拉宁可损失自己的机油（类似于人类献血、献器官）也要实现一个并没有证实对克拉拉的病情有帮助的可能可以看出。\n于是回到书中卡帕尔迪先生和乔西一家所争执的点：人工智能机器人真的可以替代人类吗？这其实也是作者给读者提出的一个问题，我本人的回答是不可以，译者的后记中有一句话我觉得特别好，这里摘抄出来：正是由于自私的欲望与升华的渴望并存，人类的心中才会充满了矛盾、彷徨与痛苦；没有了自私那下坠的重力，一切崇高、向上的人性也就虚无缥缈得失去了分量。 而后来卡帕尔迪又去找克里西，想要对她做逆向工程来安抚社会上对人工智能表示担忧的人们，这说明卡帕尔迪自认为人工智能依然是可编程、可推导的，那这和他所说的人工智能可以替代人类是不是矛盾了呢？是不是说明卡帕尔迪内心其实也不觉得可以用一个机器人代替人类，也许只是想赚钱罢了。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#什么是太阳",
    "href": "posts/klara_and_the_sun/index.html#什么是太阳",
    "title": "<克拉拉与太阳>读后感",
    "section": "什么是太阳",
    "text": "什么是太阳\n回到这本书上，我是在一个沐浴着午后的阳光的图书馆里读完的这本书，同时身边可能还充斥着很多新冠阳性病人，那么这本书里的太阳是什么呢？\n天真的克拉拉（人工智能机器人）相信太阳有神奇的力量，可以治愈疾病，而实际上乔西也确实在沐浴阳光后渐渐好转，这奠定了这是一本童话的基础，因为众所周知太阳并不能治愈疾病。然而对于克拉拉来说， 太阳可以为其提供能量，所以对她来说太阳就是她心中的上帝，类似于人类社会中基督教的上帝，或者佛教的如来等。所以当我们去寺庙或者在胸口画十字架的时候，我们是否也很天真呢？\n当然，除了物理意义上的太阳，还有一个很重要的点，那就是爱， 不管是克拉拉之于乔西，抑或里克之于乔西，克里西之于乔西，都是爱，一种如暖阳般温暖我们却又看不见摸不着的东西。\n正是因为这些爱，才有了最后完美的结局。这让我想起了诺兰的《星际穿越》，一部完美地诠释了什么叫做“爱可以穿越时空”的电影。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#关于结局",
    "href": "posts/klara_and_the_sun/index.html#关于结局",
    "title": "<克拉拉与太阳>读后感",
    "section": "关于结局",
    "text": "关于结局\n我是一个喜欢好的结局但又不希望好的作品就此陷入窠臼的人，这不是出于自认为能看透一切的自负或是受“喜剧的内核是悲剧”之类言论的影响。因为我始终认为好的作品，书或者电影，是需要留给读者和观众一定的想象空间的，类似于“留白”。\n而这个结局，的确让我想到了很多，并不局限于本书。首先是参考石黑一雄的女儿所说，这不是一本可以给孩子看的童话，它太黑暗了，于是我想到了一个大四的时候玩的游戏：《Fran Bow》，也是一个不管从画面还是故事上都十分黑暗的一款游戏，玩家们对这游戏的结局的解读也是各色各样，有人觉得整个过程都是Fran幻想出来的，有人觉得最后Fran确实去到了一个理想的世界，但就如游戏最后那句话： > I still don’t know many things… > But one thing I do know… > That between guilt and fear… > I choose happiness…\n是的，你可以选择一个开心的结局，这没有对错。\n所以我也更愿意相信克拉拉陪着乔西度过了童年，圆满完成了自己的使命，在自己的最后时刻幸福地回想着曾经的点点滴滴，这不也是我们作为人类所希望的吗？"
  },
  {
    "objectID": "posts/camille_string/index.html",
    "href": "posts/camille_string/index.html",
    "title": "实现一个简易的C++ String类",
    "section": "",
    "text": "实现String类的核心就是重写构造器和重载运算符.\n\n\n我们需要定义的有：\n\nOriginal Constructor\nCopy Constructor\nMove Constructor\nCopy Assignment\nMove Assignment\nDestructor\nIndexer\nEqual/NotEqual Operator\n\n#ifndef CAMILLE_STRING_H\n#define CAMILLE_STRING_H\n\n// using char to store\nclass String {\n  char* str;\n\npublic:\n  String(const char* s = \"\");\n  String(const String&); // copy constructor\n  String& operator=(const String&); // copy assignment\n  String(String &&) noexcept ; // move constructor\n  String& operator=(String&&) noexcept ; // move assignment\n  ~String(); // destructor\n  operator const char* ();\n  String operator+(const String&);\n  String &operator+=(const String&);\n  char operator[](int) const;\n  char &operator[](int);\n  String operator()(int, int);\n  bool operator==(const String&);\n  bool operator!=(const String&);\n};\n\n#endif"
  },
  {
    "objectID": "posts/leetcode/index.html",
    "href": "posts/leetcode/index.html",
    "title": "LeetCode 刷题记录",
    "section": "",
    "text": "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> heap;\n        for (int i = 0; i <= nums.size(); i++) {\n            int r = target - nums[i];\n            if (heap.count(r)) return {heap[r], i};\n            heap[nums[i]] = i;\n        }\n        return {};\n    }\n};\n\n\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n#include <iostream>\n\nusing namespace std;\n\n//  Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        auto dummy = new ListNode(-1), cur = dummy;\n        int t = 0;\n        while (l1 || l2 || t) {\n            if (l1) t += l1->val, l1 = l1->next;\n            if (l2) t += l2->val, l2 = l2->next;\n            cur->next = new ListNode(t % 10);\n            cur = cur->next;\n            t /= 10;\n        }\n        return dummy->next;\n    }\n};\n\n\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> heap;\n        int res = 0;\n        for (int i = 0, j = 0; i < s.size(); i++) {\n            heap[s[i]]++;\n            while (heap[s[i]] > 1) heap[s[j++]]--;\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }\n};\n\n\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int total = nums1.size() + nums2.size();\n        if (total % 2 == 0) {\n            int left = findKthNumber(nums1, 0, nums2, 0, total / 2);\n            int right = findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\n            return (left + right) / 2.0;\n        } else {\n            return findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\n        }\n    }\n\n    int findKthNumber(vector<int>& nums1, int i, vector<int>& nums2, int j, int k) {\n        if ((nums1.size() - i) > (nums2.size() - j)) return findKthNumber(nums2, j, nums1, i, k);\n        if (nums1.size() == i) return nums2[j + k - 1];\n        if (k == 1) return min(nums1[i], nums2[j]);\n        int si = min(i + k / 2, int(nums1.size())), sj = j + k / 2;\n        if (nums1[si - 1] > nums2[sj - 1]) {\n            return findKthNumber(nums1, i, nums2, sj, k - k  / 2);\n        } else {\n            return findKthNumber(nums1, si, nums2, j, k - (si - i));\n        }\n    }\n};\n\n\n\n给你一个字符串 s，找到 s 中最长的回文子串。\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        string res;\n        for (int i = 0; i < s.size(); i++) {\n            int l = i - 1, r = i + 1; // odd\n            while (l >= 0 && r <= s.size() - 1 && s[l] == s[r]) l--, r++;\n            if (res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);\n\n            l = i, r = i + 1; // even\n            while (l >= 0 && r <= s.size() - 1 && s[l] == s[r]) l--, r++;\n            if (res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);\n        }\n        return res;\n    }\n};\n\n\n\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        string res;\n        if (numRows == 1) return s;\n\n        for (int i = 0; i < numRows; i++) {\n            if (i == 0 || i == numRows - 1) {\n                for (int j = i; j < s.size(); j += 2 * numRows - 2) {\n                    res += s[j];\n                }\n            } else {\n                for (int j = i, k = 2 * numRows - 2 - i; j < s.size() || k < s.size(); j += 2 * numRows - 2, k += 2 * numRows - 2) {\n                    if (j < s.size()) res += s[j];\n                    if (k < s.size()) res += s[k];\n                }\n            }\n        }\n        return res;\n    }\n};\n\n\n\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int r = 0;\n        while (x) {\n            if (r > 0 && r > (INT_MAX - x % 10) / 10) return 0;\n            if (r < 0 && r < (INT_MIN - x % 10) / 10) return 0;\n            r = r * 10 + x % 10;\n            x /= 10;\n        }\n        return r; \n    }\n};\n\n\n\n请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n函数 myAtoi(string s) 的算法如下：\n读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -> 123， “0032” -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意：\n本题中的空白字符只包括空格字符 ’ ’ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int k = 0;\n        while (k < s.size()) {\n            if (s[k] == ' ') k++;\n            else break;\n        }\n        if (k == s.size()) return 0; \n\n        int minus = 1;\n        if (s[k] == '-') minus = -1, k++;\n        else if (s[k] == '+') k++;\n\n        int res = 0;\n        while (k < s.size() && s[k] >= '0' && s[k] <= '9') {\n            int x = s[k] - '0';\n            if (minus == 1 && res > (INT_MAX - x) / 10) return INT_MAX;\n            else if (minus == -1 && -res < (INT_MIN + x) / 10) return INT_MIN;\n            else if (minus == -1 && -res * 10 - x == INT_MIN) return INT_MIN; // different from above\n            res = res * 10 + x;\n            k++;\n        }\n        return res * minus;\n    }\n};\n\n\n\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return 0;\n\n        int y = x;\n        long long res = 0;\n        while (x) {\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        return res == y;\n    }\n};\n\n\n\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ’*’ 的正则表达式匹配。\n‘.’ 匹配任意单个字符 ’*’ 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size(), m = p.size();\n        s = ' ' + s, p = ' ' + p;\n        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));\n        f[0][0] = true;\n\n        for (int i = 0; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (j + 1 <= m && p[j + 1] == '*') continue;\n                else if (i && p[j] != '*') {\n                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');\n                } else if (p[j] == '*') {\n                    f[i][j] = f[i][j - 2] || i && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.');\n                }\n            }\n        }\n        return f[n][m];\n    }\n};\n\n\n\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int res = 0;\n        for (int i = 0, j = height.size() - 1; i < j;) {\n            res = max(res, min(height[i], height[j]) * (j - i));\n            if (height[i] > height[j]) j--;\n            else i++;\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/league_of_legends_s12/index.html",
    "href": "posts/league_of_legends_s12/index.html",
    "title": "DRX夺冠有感",
    "section": "",
    "text": "关于最后总决赛，我不知道为什么大部分人都希望SKT夺冠，希望Faker重回巅峰，偏偏我希望DRX夺冠，因为我昨天看比赛时候的心情和2017年S7一样, 就像我在第一篇博客里讲的：\n\n“所以我觉得我的2017年过的并不失败，大概我心中住了一个Ambition吧.”\n\n\n\n他和Faker同为麻浦高中的学生，同一年打职业，却在十年里辗转了七支队伍，未曾夺得一冠。\nDeft曾经也在EDG打过，正好那天的解说席上明凯也在，不知道同为追梦人，也同是队友，他心里是什么想法。\n或许他已经释然了，一辈子拿不到冠军其实才是常态，至少努力过就没什么遗憾了。\n赛后采访时Deft的一段话我觉得值得记录下来：\n\n“我唯一擅长的只有英雄联盟，如果我不能在我最擅长的事情上取得成功，那我根本不知道我的人生还有什么意义。”"
  },
  {
    "objectID": "posts/leetcode_weekly_competition/index.html",
    "href": "posts/leetcode_weekly_competition/index.html",
    "title": "LeetCode 周赛记录",
    "section": "",
    "text": "给你一个下标从 0 开始的字符串数组 words 。\n如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。\n例如，“abca” 和 “cba” 相似，因为它们都由字符 ‘a’、‘b’、‘c’ 组成。 然而，“abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。 请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 <= i < j <= word.length - 1 。\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int similarPairs(vector<string>& words) {\n        int n = words.size();\n        int ans = 0;\n        unordered_map<string, int> mp;\n        for (int i = 0; i < n; i++) {\n            string s = words[i];\n            sort(s.begin(), s.end());\n            s.erase(unique(s.begin(), s.end()), s.end());\n            ans += mp[s];\n            mp[s]++;\n        }\n        return ans;\n    }\n};\n\n\n\n给你一个正整数 n 。\n请你将 n 的值替换为 n 的 质因数 之和，重复这一过程。\n注意，如果 n 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。 返回 n 可以取到的最小值。\n#include <iostream>     \n#include <algorithm>    \n\nusing namespace std;\n\nclass Solution {\npublic:\n    // you need to prove that it is a monotonically decreasing function.\n    int work(int n) {\n        int res = 0;\n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i == 0) n /= i, res += i;\n            }\n        }\n        if (n > 1) res += n;\n        return res;\n    }\n\n    int smallestValue(int n) {\n        while (true) {\n            int next = work(n);\n            if (next == n) break;\n            n = next;\n        }\n        return n;\n    }\n};"
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "<克拉拉与太阳>读后感\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n\n\n\n\n\n\nLeetCode 周赛记录\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n\n\n\n\n\n\nLeetCode 刷题记录\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\n\n\n\n\n\n\nDRX夺冠有感\n\n\n\n\n\n\n\n\n\nNov 7, 2022\n\n\n\n\n\n\n\n\n基础算法模板\n\n\n\n\n\n\n\n\n\nNov 5, 2022\n\n\n\n\n\n\n\n\nCMU 15-213 Lab0\n\n\n\n\n\n\n\n\n\nOct 11, 2022\n\n\n\n\n\n\n\n\n实现一个简易的C++ String类\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n\n\n\n\n\n\n实现一个简易Shell\n\n\n\n\n\n\n\n\n\nSep 12, 2022\n\n\n\n\n\n\n\n\n这几年\n\n\n\n\n\n\n\n\n\nJul 4, 2022\n\n\n\n\n\n\nNo matching items"
  }
]
[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Love Camille",
    "section": "",
    "text": "All blog posts\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nLeetCode 刷题记录 21 - 30\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nJan 7, 2023\n\n\n10 min\n\n\n\n\n\n\n\n\n2022年观影记录\n\n\n\n\n\n\n\nmovie\n\n\nseries\n\n\n\n\n\n\n\n\n\n\n\nJan 7, 2023\n\n\n0 min\n\n\n\n\n\n\n\n\nLeetCode 刷题记录 11 - 20\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nJan 6, 2023\n\n\n12 min\n\n\n\n\n\n\n\n\n<克拉拉与太阳>读后感\n\n\n\n\n\n\n\nreading\n\n\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\nLeetCode 周赛记录\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n4 min\n\n\n\n\n\n\n\n\nLeetCode 刷题记录 1 - 10\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\nLeetCode\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\n11 min\n\n\n\n\n\n\n\n\nDRX夺冠有感\n\n\n\n\n\n\n\nlife\n\n\n\n\n\n\n\n\n\n\n\nNov 7, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\n基础算法模板\n\n\n\n\n\n\n\ncpp\n\n\nalgorithms\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\nCMU 15-213 Lab0\n\n\n\n\n\n\n\nc\n\n\ncmu_15_213\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\n实现一个简易的C++ String类\n\n\n\n\n\n\n\ncpp\n\n\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n0 min\n\n\n\n\n\n\n\n\n实现一个简易Shell\n\n\n\n\n\n\n\nc\n\n\n\n\n\n\n\n\n\n\n\nSep 12, 2022\n\n\n6 min\n\n\n\n\n\n\n\n\n这几年\n\n\n\n\n\n\n\nlife\n\n\n\n\n离开深圳前一些想说的话\n\n\n\n\n\n\nJul 4, 2022\n\n\n0 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Love Camille",
    "section": "",
    "text": "Hi, I’m Lov3 Camille.\nYou can find me on Twitter or GitHub. Feel free to reach out to me via mail and subscribe to my email newsletter."
  },
  {
    "objectID": "posts/camille_shell/index.html",
    "href": "posts/camille_shell/index.html",
    "title": "实现一个简易Shell",
    "section": "",
    "text": "根据Stephen Brennan的Tutorial实现的一个简易的Shell.\n\n\n一个Shell的生命周期包括三个基本部分：\n\n初始化： Shell读取并执行配置文件；\n转译： Shell读取标准输入（交互式输入或者文件）并执行；\n\n终止： 命令执行完毕，Shell执行结束命令，释放内存并终止；\n\n因此， 我们可以得到主函数的基本结构：\nint main() {\n  ls_loop();\n  return EXIT_SUCCESS;\n}\n\n\n\n循环分三步： - 读： 读取标准输入的指令； - 解析： 将输入的命令字符串分割成程序和参数； - 执行： 运行解析好的命令。\n这样我们可以得到循环体内的基本逻辑：\nvoid lsh_loop(void)\n{\n  char *line;\n  char **args;\n  int status;\n\n  do {\n    printf(\"> \");\n    line = lsh_read_line();\n    args = lsh_split_line(line);\n    status = lsh_execute(args);\n\n    free(line);\n    free(args);\n  } while (status);\n}\n\n\n\n为什么需要内置命令呢？以cd命令为例，它的作用是改变目录，那么如果Shell将该命令交给子进程去执行，那么 就只能改变子进程的目录，对于用户来说等于什么都没做，这显然不是我们想要的结果。所以需要将此类命令作为内置命令实现。\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define LSH_RL_BUF_SIZE 1024\nchar *lsh_read_line_old(void) {\n  int buf_size = LSH_RL_BUF_SIZE;\n  int position = 0;\n  char *buffer = malloc(sizeof(char) * buf_size);\n  int c;\n\n  if (!buffer) {\n    fprintf(stderr, \"lsh: allocation error\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  while (1) {\n    // Read a character\n    c = getchar();\n\n    // if we hit EOF, replace it with a null character and return\n    if (c == EOF || c == '\\n') {\n        buffer[position] = '\\0';\n        return buffer;\n    } else {\n        buffer[position] = c;\n    }\n    position++;\n\n    // if we have exceeded the buffer, reallocate\n    if (position >= buf_size) {\n        buf_size += LSH_RL_BUF_SIZE;\n        buffer = realloc(buffer, buf_size);\n        if (!buffer) {\n            fprintf(stderr, \"lsh: allocation error\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n  }\n}\n\nchar *lsh_read_line_new(void) {\n    char* line = NULL;\n    ssize_t buf_size = 0; // have getline allocate a buffer for us\n\n    if (getline(&line, &buf_size, stdin) == -1) {\n        if (feof(stdin)) {\n            exit(EXIT_SUCCESS); // we received an EOF\n        } else {\n            perror(\"readline\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    return line;\n}\n\n#define LSH_TOK_BUF_SIZE 64\n#define LSH_TOK_DELIM \" \\t\\r\\n\\a\"\nchar **lsh_split_line(char *line) {\n    int buf_size = LSH_TOK_BUF_SIZE, position = 0;\n    char **tokens = malloc(buf_size * sizeof(char*));\n    char *token;\n\n    if (!tokens) {\n        fprintf(stderr, \"lsh: allocation error\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    token = strtok(line, LSH_TOK_DELIM);\n    while (token != NULL) {\n        tokens[position] = token;\n        position++;\n\n        if (position >= buf_size) {\n            buf_size += LSH_RL_BUF_SIZE;\n            tokens = realloc(tokens, buf_size * sizeof(char*));\n            if (!tokens) {\n                fprintf(stderr, \"lsh: allocation error\\n\");\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        token = strtok(NULL, LSH_TOK_DELIM);\n    }\n    tokens[position] = NULL;\n    return tokens;\n}\n\nint lsh_launch(char** args) {\n    pid_t pid, wpid;\n    int status;\n\n    pid = fork();\n    if (pid == 0) {\n        // Child process\n        if (execvp(args[0], args) == -1) {\n            perror(\"lsh child process execute error!\");\n        }\n        exit(EXIT_FAILURE);\n    } else if (pid < 0) {\n        // Error in forking\n        perror(\"lsh fork error!\");\n    } else {\n        // Parent process\n        do {\n            wpid = waitpid(pid, &status, WUNTRACED);\n        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n    }\n    return 1;\n}\n\n/*\n * Function declaration for builtin shell commands:\n */\nint lsh_cd(char **args);\nint lsh_help(char **args);\nint lsh_exit(char **args);\n\n/*\n * List of builtin commands, followed by their corresponding functions.\n */\nchar* builtin_str[] = {\n        \"cd\",\n        \"help\",\n        \"exit\"\n};\n\nint (*builtin_func[]) (char**) = {\n        &lsh_cd,\n        &lsh_help,\n        &lsh_exit\n};\n\nint lsh_num_builtins() {\n    return sizeof(builtin_str) / sizeof(char*);\n}\n\n/*\n * Builtin function implementation\n */\nint lsh_cd(char** args) {\n    if (args[1] == NULL) {\n        fprintf(stderr, \"lsh: expected argument to \\\"cd\\\"\\n\");\n    } else {\n        if (chdir(args[1]) != 0) {\n            perror(\"lsh change directory error!\");\n        }\n    }\n    return 1;\n}\n\nint lsh_help(char** args) {\n    int i;\n    printf(\"LSH from scratch\\n\");\n    printf(\"Type program names and arguments, and hit enter.\\n\");\n    printf(\"The following are built in:\\n\");\n\n    for (i = 0; i < lsh_num_builtins(); i++) {\n        printf(\" %s\\n\", builtin_str[i]);\n    }\n\n    printf(\"Use the man command for information and other programs.\\n\");\n    return 1;\n}\n\nint lsh_exit(char** args) {\n    return 0;\n}\n\nint lsh_execute(char **args) {\n    int i;\n    if (args[0] == NULL) {\n        // An empty command was entered.\n        return 1;\n    }\n    // Find the matched builtin command and execute it\n    for (i = 0; i < lsh_num_builtins(); i++) {\n        if (strcmp(args[0], builtin_str[i]) == 0) {\n            return (*builtin_func[i])(args);\n        }\n    }\n    return lsh_launch(args);\n}\n\nvoid ls_loop(void) {\n    char *line;\n    char **args;\n    int status;\n\n    do {\n        printf(\"> \");\n        line = lsh_read_line_new();\n        args = lsh_split_line(line);\n        status = lsh_execute(args);\n    } while (status);\n}\n\nint main() {\n  ls_loop();\n  return EXIT_SUCCESS;\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html",
    "href": "posts/basic_algorithms/index.html",
    "title": "基础算法模板",
    "section": "",
    "text": "#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nint n;\nint q[N];\n\nvoid quick_sort(int q[], int l, int r) {\n    if (l >= r) {\n        return;\n    }\n\n    int x = q[l], i = l - 1, j = r + 1;\n\n    while (i < j) {\n        do i++; while (q[i] < x);\n        do j--; while (q[j] > x);\n        if (i < j) {\n            swap(q[i], q[j]);\n        }\n    }\n\n    quick_sort(q, l, j); \n    quick_sort(q, j + 1, r);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &q[i]);\n    }\n\n    quick_sort(q, 0, n - 1);\n\n    for (int j = 0; j < n; j++) {\n        printf(\"%d\", q[j]);\n    };\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#整数二分",
    "href": "posts/basic_algorithms/index.html#整数二分",
    "title": "基础算法模板",
    "section": "整数二分",
    "text": "整数二分\n给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。\n对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。\n如果数组中不存在该元素，则返回 -1 -1。\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100000;\n\nint n, m;\nint q[N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n\n    for (int i = 0; i < n; i++) scanf(\"%d\", &q[i]);\n\n    while (m--) {\n        int x;\n        scanf(\"%d\", &x);\n\n        int l = 0, r = n - 1;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (x <= q[mid]) r = mid; // fetch the left border\n            else l = mid + 1; \n        }\n        if (q[l] != x) cout << \"-1 -1\" << endl;\n        else {\n            cout << l << \" \";\n\n            l = 0, r = n - 1;\n            while (l < r) {\n                int mid = l + r + 1 >> 1;\n                if (x >= q[mid]) l = mid; // fetch the right border\n                else r = mid - 1;\n            }\n            cout << l << endl;\n        }\n    }\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#浮点数二分",
    "href": "posts/basic_algorithms/index.html#浮点数二分",
    "title": "基础算法模板",
    "section": "浮点数二分",
    "text": "浮点数二分\n求一个数的平方根。\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    double x;\n    cin >> x;\n\n    double l = 0, r = x;\n\n    while (r - l > 1e-8) {\n        double mid = (l + r) / 2;\n        if (mid * mid > x) r = mid;\n        else l = mid; \n    }\n\n    printf(\"%f\\n\", l);\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#加法",
    "href": "posts/basic_algorithms/index.html#加法",
    "title": "基础算法模板",
    "section": "加法",
    "text": "加法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\nvector<int> add(vector<int> &A, vector<int> &B) {\n    vector<int> C;\n    \n    int t = 0;\n\n    for (int i = 0; i < A.size() || i < B.size(); i++) {\n        if (i < A.size()) t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t = t / 10;\n    }\n    if (t) C.push_back(t);\n    return C;\n}\n\nint main() {\n    string a, b;\n    vector<int> A, B;\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); // convert char to int\n    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');\n\n    vector<int> C = add(A, B);\n\n    for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n\n    return 0;\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#减法",
    "href": "posts/basic_algorithms/index.html#减法",
    "title": "基础算法模板",
    "section": "减法",
    "text": "减法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\n\n// compare A and B\nbool cmp(vector<int> &A, vector<int> &B) {\n    if (A.size() != B.size()) return A.size() > B.size();\n    for (int i = 0; i < A.size(); i++) {\n        if (A[i] != B[i]) return A[i] > B[i];\n    }\n    return true;\n}\n\nvector<int> sub(vector<int> &A, vector<int> &B) {\n    vector<int> C;\n    for (int i = 0, t = 0; i < A.size(); i++) {\n        t = A[i] - t;\n        if (i < B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t < 0) t = 1;\n        else t = 0;\n    }\n    while (C.size() > 1 && C.back() == 0) C.pop_back(); // remember to delete redundant zero\n    return C;\n}\n\nint main() {\n    string a, b;\n    vector<int> A, B;\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');\n\n    if (cmp(A, B)) {\n        auto C = sub(A, B);\n        for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n    } else {\n        auto C = sub(B, A);\n        printf(\"-\");\n        for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n    }\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#乘法",
    "href": "posts/basic_algorithms/index.html#乘法",
    "title": "基础算法模板",
    "section": "乘法",
    "text": "乘法\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> mul(vector<int> &A, int b) {\n    int t = 0;\n    vector<int> C;\n    for (int i = 0; i < A.size() || t; i++) {\n        if (i < A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    return C;\n}\n\nint main() {\n    string a;\n    vector<int> A;\n    int b;\n\n    cin >> a >> b;\n\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n\n    auto C = mul(A, b);\n\n    if (C[C.size() - 1] == 0) cout << 0 << endl;\n\n    else for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n}"
  },
  {
    "objectID": "posts/basic_algorithms/index.html#除法",
    "href": "posts/basic_algorithms/index.html#除法",
    "title": "基础算法模板",
    "section": "除法",
    "text": "除法\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> div(vector<int> &A, int b, int &r) {\n    vector<int> C;\n    r = 0;\n\n    for (int i = A.size(); i >= 0; i--) {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n\n    reverse(C.begin(), C.end());\n\n    while (C.size() > 1 && C.back() == 0) C.pop_back();\n\n    return C;\n}\n\nint main() {\n    string a;\n    int b;\n    \n    cin >> a >> b;\n\n    vector<int> A;\n    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');\n\n    int r;\n    auto C = div(A, b, r);\n\n    for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]);\n\n    cout << endl << r << endl;\n}"
  },
  {
    "objectID": "posts/cmu_15-213_lab0/index.html",
    "href": "posts/cmu_15-213_lab0/index.html",
    "title": "CMU 15-213 Lab0",
    "section": "",
    "text": "利用C语言实现一个队列的基本功能，包括：\n\n创建队列\n销毁队列\n头部入队\n尾部入队\n头部出队\n获取队列长度\n反转队列\n\n核心在于每次对队列操作前都要考虑是否为空的情况，保证代码的鲁棒性。\n\n\n#include <stdbool.h>\n#include <stddef.h>\n\n/* element struct in queue */\ntypedef struct list_ele {\n    char *value;\n    struct list_ele *next;\n} list_ele_t;\n\ntypedef struct {\n    list_ele_t *head;\n    list_ele_t *tail;\n    int size; // use the above two variable to record the size of the queue to avoid traversal\n} queue_t;\n\n/* Create empty queue. */\nqueue_t *queue_new(void);\n\n/* Free ALL storage used by queue. */\nvoid queue_free(queue_t *q);\n\n/* Attempt to insert element at head of queue. */\nbool queue_insert_head(queue_t *q, const char *s);\n\n/* Attempt to insert element at tail of queue. */\nbool queue_insert_tail(queue_t *q, const char *s);\n\n/* Attempt to remove element from head of queue. */\nbool queue_remove_head(queue_t *q, char *sp, size_t bufsize);\n\n/* Return number of elements in queue. */\nsize_t queue_size(queue_t *q);\n\n/* Reverse elements in queue */\nvoid queue_reverse(queue_t *q);\n可以看到，在源文件的基础上，新增了尾节点和队列大小两个属性，当然也可以不加，但如果没有这两个变量，计算队列大小或者进行尾部入队操作的时间复杂度就不是常量了，而是线性增长的。\n下面我们具体看每个函数的实现。\n\n\n\n/**\n * @brief Allocates a new queue\n * @return The new queue, or NULL if memory allocation failed\n */\nqueue_t *queue_new(void) {\n    queue_t *q = malloc(sizeof(queue_t));\n    /* What if malloc returned NULL? */\n    if (q == NULL) {\n        return NULL;\n    } else {\n        q->head = NULL;\n        q->tail = NULL;\n        q->size = 0;\n        return q;\n    }\n}\n这一步没什么问题，主要就是分配队列空间并初始化队列的各个属性。\n\n\n\n/**\n * @brief Frees all memory used by a queue\n * @param[in] q The queue to free\n */\nvoid queue_free(queue_t *q) {\n    /* How about freeing the list elements and the strings? */\n    /* Free queue structure */\n    if (q == NULL) {\n        return;\n    } else {\n        list_ele_t *tmp;\n        while (q->head != NULL) {\n            tmp = q->head;\n            q->head = q->head->next;\n            free(tmp->value); // free element's value\n            free(tmp) // free element itself\n        }\n    }\n    free(q); // free queue\n}\n如上所述，判断完队列是否为空，还需要判断队列的属性是否为空。\n\n\n\n/**\n * @brief Attempts to insert an element at head of a queue\n *\n * This function explicitly allocates space to create a copy of `s`.\n * The inserted element points to a copy of `s`, instead of `s` itself.\n *\n * @param[in] q The queue to insert into\n * @param[in] s String to be copied and inserted into the queue\n *\n * @return true if insertion was successful\n * @return false if q is NULL, or memory allocation failed\n */\nbool queue_insert_head(queue_t *q, const char *s) {\n    list_ele_t *newh;\n    /* What should you do if the q is NULL? */\n    if (q == NULL) {\n        return false;\n    }\n    /* Don't forget to allocate space for the string and copy it */\n    /* What if either call to malloc returns NULL? */\n    newh = malloc(sizeof(list_ele_t));\n    if (newh == NULL) {\n        return false;\n    } else {\n        newh->value = malloc(sizeof(char) * (strlen(s) + 1));\n        if (newh->value == NULL) {\n            free(newh); // must free the space if malloc failed\n            return false;\n        } else {\n            strcpy(newh->value, s);\n            newh->next = q->head;\n            q->head = newh;\n\n            if (q->tail == NULL) {\n                q->tail = newh;\n            }\n            ++q->size;\n            return true;\n        }\n    }\n}\n除了判断队列及队列元素是否为空，还要判断malloc()是否成功， 正常来讲，内存分配成功的话，会返回一个可以指向任意类型的指针，但该指针必须通过free()或者realloc()回收。 如果分配失败了，会返回一个空指针，我们需要对其进行判断。\n\n\n\n/**\n * @brief Attempts to insert an element at tail of a queue\n *\n * This function explicitly allocates space to create a copy of `s`.\n * The inserted element points to a copy of `s`, instead of `s` itself.\n *\n * @param[in] q The queue to insert into\n * @param[in] s String to be copied and inserted into the queue\n *\n * @return true if insertion was successful\n * @return false if q is NULL, or memory allocation failed\n */\nbool queue_insert_tail(queue_t *q, const char *s) {\n    /* You need to write the complete code for this function */\n    /* Remember: It should operate in O(1) time */\n    list_ele_t *newt;\n    /* What should you do if the q is NULL? */\n    if (q == NULL) {\n        return false;\n    }\n    /* Don't forget to allocate space for the string and copy it */\n    /* What if either call to malloc returns NULL? */\n    newt = malloc(sizeof(list_ele_t));\n    if (newt == NULL) {\n        return false;\n    } else {\n        newt->value = malloc(sizeof(char) * (strlen(s) + 1));\n        if (newt->value == NULL) {\n            free(newt);\n            return false;\n        } else {\n            strcpy(newt->value, s);\n            newt->next = NULL;\n\n            if (q->tail != NULL) {\n                q->tail->next = newt;\n                q->tail = newt;\n            } else {\n                q->head = newt;\n                q->tail = newt;\n            }\n            ++q->size;\n            return true;\n        }\n    }\n}\n这一步和头部入队类似，不同点在于需要对尾节点是否存在进行判断，而头部入队时是不需要判断头节点是否存在的，因为必然要进行重新分配且不需要对其执行查找下一个节点的操作。\n\n\n\n/**\n * @brief Attempts to remove an element from head of a queue\n *\n * If removal succeeds, this function frees all memory used by the\n * removed list element and its string value before returning.\n *\n * If removal succeeds and `buf` is non-NULL, this function copies up to\n * `bufsize - 1` characters from the removed string into `buf`, and writes\n * a null terminator '\\0' after the copied string.\n *\n * @param[in]  q       The queue to remove from\n * @param[out] buf     Output buffer to write a string value into\n * @param[in]  bufsize Size of the buffer `buf` points to\n *\n * @return true if removal succeeded\n * @return false if q is NULL or empty\n */\nbool queue_remove_head(queue_t *q, char *buf, size_t bufsize) {\n    if (q == NULL) {\n        return false;\n    }\n    if (q->head == NULL) {\n        return false;\n    } else {\n        list_ele_t *temp = q->head;\n        q->head = q->head->next;\n        if (buf != NULL) {\n            strncpy(buf, temp->value, bufsize - 1);\n            buf[bufsize - 1] = '\\0';\n        }\n        free(temp->value);\n        free(temp);\n        --q->size;\n    }\n    return true;\n}\n这里注意一下strncpy的用法就好了，要保证buf是C-Style的字符数组。\n\n\n\n/**\n * @brief Returns the number of elements in a queue\n *\n * This function runs in O(1) time.\n *\n * @param[in] q The queue to examine\n *\n * @return the number of elements in the queue, or\n *         0 if q is NULL or empty\n */\nsize_t queue_size(queue_t *q) {\n    /* You need to write the code for this function */\n    /* Remember: It should operate in O(1) time */\n    if (q == NULL) {\n        return 0;\n    } else {\n        return q->size;\n    }\n}\n这没什么好说的，在前面执行入队、出队的时候不要忘记修改size的值就可以，这里只需要直接返回，而不需要通过遍历队列的方式去计算。\n\n\n\n/**\n * @brief Reverse the elements in a queue\n *\n * This function does not allocate or free any list elements, i.e. it does\n * not call malloc or free, including inside helper functions. Instead, it\n * rearranges the existing elements of the queue.\n *\n * @param[in] q The queue to reverse\n */\nvoid queue_reverse(queue_t *q) {\n    /* You need to write the code for this function */\n    if (q == NULL || q->head == NULL) {\n        return;\n    } else {\n        list_ele_t *oldHead = q->head;\n        list_ele_t *oldTail = q->tail;\n\n        list_ele_t *temp = q->head;\n        list_ele_t *prev = NULL;\n        list_ele_t *next = NULL;\n        while (temp != NULL) {\n            next = temp->next;\n            temp->next = prev;\n            prev = temp;\n            temp = next;\n        }\n        q->head = oldTail;\n        q->tail = oldHead;\n    }\n}\n经典的反转链表，这里就不赘述了。\n\n\n\n一共是提供了十五组测试用例，满分一百，包括了对各个函数及其性能的测试(测试尾部入队10000个元素)，还有鲁棒性测试（释放空队列的空间，从空队列中移除头部元素等），还是比较全面的。"
  },
  {
    "objectID": "posts/new_beginnings/index.html",
    "href": "posts/new_beginnings/index.html",
    "title": "这几年",
    "section": "",
    "text": "“有个阴天，没有下雨，但我到公司后还是和前台借了一把伞，过了几天准备下楼还伞的时候，外面却下起了大雨，而那天很多人都没伞。”"
  },
  {
    "objectID": "posts/new_beginnings/index.html#流水账",
    "href": "posts/new_beginnings/index.html#流水账",
    "title": "这几年",
    "section": "流水账",
    "text": "流水账\n2020年初拿到港中文offer，从上一家公司离职后，一直踌躇满志，找了很多关于如何学习计算机的资料，想着自己终于可以做自己喜欢的事情了。于是在闵行租了一个小屋子， 天天闷在里面学习、打游戏、抽烟、睡懒觉，日复一日。\n过了几个月，去了西安和女朋友呆一起，本来以为过不了多久就去香港了，结果疫情严重，全部改为网课，就这样一边上网课，一边试了下秋招，结果一律过不了初面。终于发现，学校教的和工作需要的其实并不完全一致。但不管怎样，虽说是上网课，也和几个同学相谈甚欢，学到了不少。\n就这样，直到十二月份，我才开始看一些培训班的视频，开着两倍速，不知道比刚开始抱着《JAVA核心技术》一个字一个字啃要快多少倍。很快，十二月底，拿到了腾讯的实习和华为的留学生秋招offer。\n在腾讯实习了几个月之后又去了阿里实习，后来秋招又拿了一些offer，最后在2021年底正式入职腾讯。\n再后来，从今年4月初开始，日子一直不好过，为了避免被裁或是为了缓解老板的焦虑，我们表演式加班，一天又一天。结果6月27号还是通知我被裁了，可笑的是，第二天又被通知有应届生保护政策留下了（事实上我早就想走了），最后经过一番协商，也给了些赔偿。现在发这篇博客的时候离我离职日期正好还剩一周。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#慎",
    "href": "posts/new_beginnings/index.html#慎",
    "title": "这几年",
    "section": "慎",
    "text": "慎\n我平时爱玩英雄联盟，也感谢腾讯每个月业务体验福利让我这个穷b摇身一变成了皮肤狗。但我现在爱玩这个游戏和刚开始玩它的理由已经有了很大不同。刚开始是因为大家都玩，军校里也没啥别的娱乐方式，去游戏里杀人排解烦闷罢了。现在我倒是会研究各个英雄的台词。虽说也是人编出来的，但多少给我点启发。\n就比如暮光之眼-慎，他有几句台词：\n\n“Tread carefully（要步步为营）”\n\n\n“A demonstration of superior judgement（您果然深思熟虑）”\n\n从去年实习开始，我就骑驴找马，再后来拒秋招offer的时候，我给的理由都是我去读博了，事实上我确实有考虑读博。然后今年四月份的某个加班到十点的晚上，我在回家的路上突然就决定去要回我去年的offer。\n无奈过程令人煎熬，一直到通知被裁后两周才最终敲定，这三个月滋味真不好受。但有时候想想我那装精神病三个月，期间一次没碰过电子产品的军校同学，大概也有异曲同工之妙吧。\n现在回想起来，慎这个英雄大概真的影响到了我，要时刻保持谨慎，要有全局思维。而我做这些决定的时候，并没有想太多，大概就类似于游戏里的肌肉记忆吧。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#ambition",
    "href": "posts/new_beginnings/index.html#ambition",
    "title": "这几年",
    "section": "Ambition",
    "text": "Ambition\n为什么会突然想到Ambition这个选手呢？因为我2017年退伍，病床上看S7的比赛，看EDG一万经济被翻盘，看EDG的粉丝在赛场外哭到呕吐。而那一年Ambition打败Faker，拿下了S7的冠军，我却考研失败。\n但回顾Ambition的职业生涯，2012年以中单成名，2013年被Faker单杀，开始走下坡路，那一年正好我进入科大。\n所以我觉得我的2017年过的并不失败，大概我心中住了一个Ambition吧。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#朋友",
    "href": "posts/new_beginnings/index.html#朋友",
    "title": "这几年",
    "section": "朋友",
    "text": "朋友\n我有几个同学，平时喜欢一起玩英雄联盟，喜欢四黑然后在快赢的时候点投降，喜欢一起住电竞酒店，喜欢抽着烟漫步在凌晨的淮海中路被人问要不要代驾（其实是需要代练），喜欢在KTV听渣威的《童话镇》、阿杰的《像我这样的人》、阿煊的《夏日寒风》却没钱点酒，喜欢找女陪玩结果发现大部分除了发嗲别的啥都不会。\n就这样过了几年，直到大家都没力气通宵，没力气抽烟，直到唯一一个打的很好的女陪玩也弃游了，直到大家都有了女朋友甚至老婆。\n我们最近一次共同经历的事已经不是英雄联盟了，居然是部队问我们要那多发的两个月津贴，大伙都不想给，于是支付了一杯奶茶钱当律师费，然后心满意足地发现自己当老赖的想法得到了律师的认可。\n但我还是会每天上游戏玩个一两把，看着右边黑乎乎的好友栏，看着只有一个亮起的ID，那个人叫“还在等她说晚安”。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#工作",
    "href": "posts/new_beginnings/index.html#工作",
    "title": "这几年",
    "section": "工作",
    "text": "工作\n算上实习，算上陆院那几个月，也工作了快四年了，期间兜兜转转，从南昌到上海，从上海到深圳，现在又回到上海，我一直嘲笑老婆工作不稳定，老是出差，但她都在同一个地方工作五年了，我却换了五个地方。"
  },
  {
    "objectID": "posts/new_beginnings/index.html#未来",
    "href": "posts/new_beginnings/index.html#未来",
    "title": "这几年",
    "section": "未来",
    "text": "未来\n最近在重读古龙，后面计划写些读后感，希望能赚点钱买纸质书而不是网上下盗版，希望家里房子顺利盖好，希望家人和朋友身体健康、工作顺利。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html",
    "href": "posts/klara_and_the_sun/index.html",
    "title": "<克拉拉与太阳>读后感",
    "section": "",
    "text": "很久没写过读后感了，上次写应该还是在高中，从小学到高中读过很多书和期刊，也正是这些书塑造了我的一部分人格，所以我必须感谢这些书，以及给予我阅读条件的爸妈、外婆、老师。\n关于《克拉拉与太阳》这本书，从买回来到读完，花了快一年，深圳买来，上海读完，期间也换了工作，经历了似乎发生了很多事又似乎什么都没发生的2022年。\n至于我为什么花了一年才读完，相信现代人很能理解，因为手机和电脑已经占据了我们的工作与生活，重新拿起纸质书本就不容易。但仔细一想，其实每天读一些也能很快读完，说到底还是自己懒，但毕竟这是这几年第一本完整读完的纸质书，值得纪念一下。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#什么是克拉拉",
    "href": "posts/klara_and_the_sun/index.html#什么是克拉拉",
    "title": "<克拉拉与太阳>读后感",
    "section": "什么是克拉拉",
    "text": "什么是克拉拉\n克拉拉是一个专为陪伴儿童而设计的太阳能人工智能机器人，具有极高的观察、推理与共情能力。在石黑一雄的采访中，他有提到很关注甚至担忧人工智能的发展，但我个人认为人类要理解产生智力的机制这一关键因素才有可能生产出有共情能力的机器人，而我们离这一步还有很长的路要走。\n那么显然在书中人类社会已经具备了生产这类机器人的能力，并且还在不断升级，因为克拉拉并不是最新型号的那一批。而且从书的结尾也不难发现，这已经成了一条流水线，从生产到投入商店到折旧回收，已经不足为奇。还有一个很重要的点是这些机器人只会一心一意地为主人着想，百分之百利他。这一点从克拉拉宁可损失自己的机油（类似于人类献血、献器官）也要实现一个并没有证实对克拉拉的病情有帮助的可能可以看出。\n于是回到书中卡帕尔迪先生和乔西一家所争执的点：人工智能机器人真的可以替代人类吗？这其实也是作者给读者提出的一个问题，我本人的回答是不可以，译者的后记中有一句话我觉得特别好，这里摘抄出来：正是由于自私的欲望与升华的渴望并存，人类的心中才会充满了矛盾、彷徨与痛苦；没有了自私那下坠的重力，一切崇高、向上的人性也就虚无缥缈得失去了分量。 而后来卡帕尔迪又去找克里西，想要对她做逆向工程来安抚社会上对人工智能表示担忧的人们，这说明卡帕尔迪自认为人工智能依然是可编程、可推导的，那这和他所说的人工智能可以替代人类是不是矛盾了呢？是不是说明卡帕尔迪内心其实也不觉得可以用一个机器人代替人类，也许只是想赚钱罢了。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#什么是太阳",
    "href": "posts/klara_and_the_sun/index.html#什么是太阳",
    "title": "<克拉拉与太阳>读后感",
    "section": "什么是太阳",
    "text": "什么是太阳\n回到这本书上，我是在一个沐浴着午后的阳光的图书馆里读完的这本书，同时身边可能还充斥着很多新冠阳性病人，那么这本书里的太阳是什么呢？\n天真的克拉拉（人工智能机器人）相信太阳有神奇的力量，可以治愈疾病，而实际上乔西也确实在沐浴阳光后渐渐好转，这奠定了这是一本童话的基础，因为众所周知太阳并不能治愈疾病。然而对于克拉拉来说， 太阳可以为其提供能量，所以对她来说太阳就是她心中的上帝，类似于人类社会中基督教的上帝，或者佛教的如来等。所以当我们去寺庙或者在胸口画十字架的时候，我们是否也很天真呢？\n当然，除了物理意义上的太阳，还有一个很重要的点，那就是爱， 不管是克拉拉之于乔西，抑或里克之于乔西，克里西之于乔西，都是爱，一种如暖阳般温暖我们却又看不见摸不着的东西。\n正是因为这些爱，才有了最后完美的结局。这让我想起了诺兰的《星际穿越》，一部完美地诠释了什么叫做“爱可以穿越时空”的电影。"
  },
  {
    "objectID": "posts/klara_and_the_sun/index.html#关于结局",
    "href": "posts/klara_and_the_sun/index.html#关于结局",
    "title": "<克拉拉与太阳>读后感",
    "section": "关于结局",
    "text": "关于结局\n我是一个喜欢好的结局但又不希望好的作品就此陷入窠臼的人，这不是出于自认为能看透一切的自负或是受“喜剧的内核是悲剧”之类言论的影响。因为我始终认为好的作品，书或者电影，是需要留给读者和观众一定的想象空间的，类似于“留白”。\n而这个结局，的确让我想到了很多，并不局限于本书。首先是参考石黑一雄的女儿所说，这不是一本可以给孩子看的童话，它太黑暗了，于是我想到了一个大四的时候玩的游戏：《Fran Bow》，也是一个不管从画面还是故事上都十分黑暗的一款游戏，玩家们对这游戏的结局的解读也是各色各样，有人觉得整个过程都是Fran幻想出来的，有人觉得最后Fran确实去到了一个理想的世界，但就如游戏最后那句话：\n\n“I still don’t know many things…”\n\n\n“But one thing I do know…”\n\n\n“That between guilt and fear…”\n\n\n“I choose happiness…”\n\n是的，你可以选择一个开心的结局，这没有对错。\n所以我也更愿意相信克拉拉陪着乔西度过了童年，圆满完成了自己的使命，在自己的最后时刻幸福地回想着曾经的点点滴滴，这不也是我们作为人类所希望的吗？"
  },
  {
    "objectID": "posts/movie_record_2022/index.html",
    "href": "posts/movie_record_2022/index.html",
    "title": "2022年观影记录",
    "section": "",
    "text": "2022年看过的电影\n\n\n2022年看过的电视剧"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html",
    "href": "posts/leetcode_21-30/index.html",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "",
    "text": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        auto dummy = new ListNode(-1), tail = dummy;\n        while (l1 && l2) {\n            if (l1->val > l2->val) {\n                tail = tail->next = l2;\n                l2 = l2->next;\n            } else {\n                tail = tail->next = l1;\n                l1 = l1->next;\n            }\n        }\n        if (l1) tail->next = l1;\n        if (l2) tail->next = l2;\n\n        return dummy->next;\n    }   \n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#括号生成",
    "href": "posts/leetcode_21-30/index.html#括号生成",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "22. 括号生成",
    "text": "22. 括号生成\n数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> res;\n    \n    vector<string> generateParenthesis(int n) {\n        dfs(n, 0, 0, \"\");\n        return res;\n    }\n\n    void dfs(int n, int lc, int rc, string path) {\n        if (lc == n && rc == n) res.push_back(path);\n        else {\n            if (lc < n) dfs(n, lc + 1, rc, path + \"(\");\n            if (rc < n && lc > rc) dfs(n, lc, rc + 1, path + \")\");\n        }\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#合并k个升序链表",
    "href": "posts/leetcode_21-30/index.html#合并k个升序链表",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "23. 合并K个升序链表",
    "text": "23. 合并K个升序链表\n给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \nclass Solution {\npublic:\n    struct Cmp {\n        bool operator() (ListNode* a, ListNode* b) {\n            return a->val > b->val;\n        }\n    };\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<ListNode*, vector<ListNode*>, Cmp> heap;\n        auto dummy = new ListNode(-1), tail = dummy;\n        for (auto& l : lists) if (l) heap.push(l);\n\n        while (heap.size()) {\n            ListNode* t = heap.top();\n            heap.pop();\n\n            tail = tail->next = t;\n            if (t->next) heap.push(t->next);\n        }\n        return dummy->next;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#两两交换链表中的节点",
    "href": "posts/leetcode_21-30/index.html#两两交换链表中的节点",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "24. 两两交换链表中的节点",
    "text": "24. 两两交换链表中的节点\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n\n        for (auto p = dummy; p->next && p->next->next;) {\n            auto a = p->next, b = a->next;\n            p->next = b;\n            a->next = b->next;\n            b->next = a;\n            p = a;\n        }\n\n        return dummy->next;\n    }   \n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#k-个一组翻转链表",
    "href": "posts/leetcode_21-30/index.html#k-个一组翻转链表",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "25. K 个一组翻转链表",
    "text": "25. K 个一组翻转链表\n给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n\n        for (auto p = dummy;;) {\n            // check if length bigger or equals to k.\n            auto q = p;\n            for (int i = 0; i < k && q; i++) q = q->next;\n            if (!q) break;\n            // reverse k-len linked list.\n            auto a = p->next, b = a->next; \n            for (int i = 0; i < k - 1; i++) {\n                auto c = b->next;\n                b->next = a;\n                a = b, b = c;\n            }\n            // change dummy head to next k-len linked list.\n            auto d = p->next;\n            p->next = a, d->next = b;\n            p = d;\n        }\n\n        return dummy->next;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#删除有序数组中的重复项",
    "href": "posts/leetcode_21-30/index.html#删除有序数组中的重复项",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "26. 删除有序数组中的重复项",
    "text": "26. 删除有序数组中的重复项\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (!i || nums[i] != nums[i - 1]) nums[k++] = nums[i];\n        }\n        return k;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#移除元素",
    "href": "posts/leetcode_21-30/index.html#移除元素",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "27. 移除元素",
    "text": "27. 移除元素\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int k = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != val) nums[k++] = nums[i];\n        }\n        return k;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#找出字符串中第一个匹配项的下标",
    "href": "posts/leetcode_21-30/index.html#找出字符串中第一个匹配项的下标",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "28. 找出字符串中第一个匹配项的下标",
    "text": "28. 找出字符串中第一个匹配项的下标\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int strStr(string s, string p) {\n        int n = s.size(), m = p.size();\n        // consider case when s and p are both empty.\n        if (p.empty() && s.empty()) return 0;\n        \n        s = ' ' + s, p = ' ' + p;\n        // calculate NEXT array, consider s as p.\n        vector<int> next(m + 1);\n        for (int i = 2, j = 0; i <= m; i++) {\n            while (j && p[i] != p[j + 1]) j = next[j];\n            if (p[i] == p[j + 1]) j++;\n            next[i] = j;\n        } \n\n        for (int i = 1, j = 0; i <= n; i++) {\n            while (j && s[i] != p[j + 1]) j = next[j];\n            if (s[i] == p[j + 1]) j++;\n            if (j == m) return i - m;\n        }\n        return -1;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_21-30/index.html#两数相除",
    "href": "posts/leetcode_21-30/index.html#两数相除",
    "title": "LeetCode 刷题记录 21 - 30",
    "section": "29. 两数相除",
    "text": "29. 两数相除\n给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。\n整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。\n返回被除数 dividend 除以除数 divisor 得到的 商 。\n注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。\n#include <vector>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int divide(int x, int y) {\n        typedef long long ll;\n        vector<ll> exp;\n        ll res = 0;\n        bool is_minus = false;\n        if (x < 0 && y > 0 || x > 0 && y < 0) is_minus = true;\n        ll a = abs((ll)x), b = abs((ll)y);\n\n        for (ll i = b; i <= a; i = i + i) exp.push_back(i);\n\n        for (int i = exp.size() - 1; i >= 0; i--) {\n            if (a >= exp[i]) {\n                a -= exp[i];\n                res += 1ll << i;\n            }\n        }\n\n        if (is_minus) res = -res;\n        if (res > INT_MAX) res = INT_MAX;\n        if (res < INT_MIN) res = INT_MIN;\n\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/camille_string/index.html",
    "href": "posts/camille_string/index.html",
    "title": "实现一个简易的C++ String类",
    "section": "",
    "text": "实现String类的核心就是重写构造器和重载运算符.\n\n\n我们需要定义的有：\n\nOriginal Constructor\nCopy Constructor\nMove Constructor\nCopy Assignment\nMove Assignment\nDestructor\nIndexer\nEqual/NotEqual Operator\n\n#ifndef CAMILLE_STRING_H\n#define CAMILLE_STRING_H\n\n// using char to store\nclass String {\n  char* str;\n\npublic:\n  String(const char* s = \"\");\n  String(const String&); // copy constructor\n  String& operator=(const String&); // copy assignment\n  String(String &&) noexcept ; // move constructor\n  String& operator=(String&&) noexcept ; // move assignment\n  ~String(); // destructor\n  operator const char* ();\n  String operator+(const String&);\n  String &operator+=(const String&);\n  char operator[](int) const;\n  char &operator[](int);\n  String operator()(int, int);\n  bool operator==(const String&);\n  bool operator!=(const String&);\n};\n\n#endif"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html",
    "href": "posts/leetcode_1-10/index.html",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "",
    "text": "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> heap;\n        for (int i = 0; i <= nums.size(); i++) {\n            int r = target - nums[i];\n            if (heap.count(r)) return {heap[r], i};\n            heap[nums[i]] = i;\n        }\n        return {};\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#两数相加",
    "href": "posts/leetcode_1-10/index.html#两数相加",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "2. 两数相加",
    "text": "2. 两数相加\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n#include <iostream>\n\nusing namespace std;\n\n//  Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        auto dummy = new ListNode(-1), cur = dummy;\n        int t = 0;\n        while (l1 || l2 || t) {\n            if (l1) t += l1->val, l1 = l1->next;\n            if (l2) t += l2->val, l2 = l2->next;\n            cur->next = new ListNode(t % 10);\n            cur = cur->next;\n            t /= 10;\n        }\n        return dummy->next;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#无重复字符的最长字串",
    "href": "posts/leetcode_1-10/index.html#无重复字符的最长字串",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "3. 无重复字符的最长字串",
    "text": "3. 无重复字符的最长字串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int> heap;\n        int res = 0;\n        for (int i = 0, j = 0; i < s.size(); i++) {\n            heap[s[i]]++;\n            while (heap[s[i]] > 1) heap[s[j++]]--;\n            res = max(res, i - j + 1);\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#寻找两个正序数组的中位数",
    "href": "posts/leetcode_1-10/index.html#寻找两个正序数组的中位数",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "4. 寻找两个正序数组的中位数",
    "text": "4. 寻找两个正序数组的中位数\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int total = nums1.size() + nums2.size();\n        if (total % 2 == 0) {\n            int left = findKthNumber(nums1, 0, nums2, 0, total / 2);\n            int right = findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\n            return (left + right) / 2.0;\n        } else {\n            return findKthNumber(nums1, 0, nums2, 0, total / 2 + 1);\n        }\n    }\n\n    int findKthNumber(vector<int>& nums1, int i, vector<int>& nums2, int j, int k) {\n        if ((nums1.size() - i) > (nums2.size() - j)) return findKthNumber(nums2, j, nums1, i, k);\n        if (nums1.size() == i) return nums2[j + k - 1];\n        if (k == 1) return min(nums1[i], nums2[j]);\n        int si = min(i + k / 2, int(nums1.size())), sj = j + k / 2;\n        if (nums1[si - 1] > nums2[sj - 1]) {\n            return findKthNumber(nums1, i, nums2, sj, k - k  / 2);\n        } else {\n            return findKthNumber(nums1, si, nums2, j, k - (si - i));\n        }\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#最长回文子串",
    "href": "posts/leetcode_1-10/index.html#最长回文子串",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "5. 最长回文子串",
    "text": "5. 最长回文子串\n给你一个字符串 s，找到 s 中最长的回文子串。\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        string res;\n        for (int i = 0; i < s.size(); i++) {\n            int l = i - 1, r = i + 1; // odd\n            while (l >= 0 && r <= s.size() - 1 && s[l] == s[r]) l--, r++;\n            if (res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);\n\n            l = i, r = i + 1; // even\n            while (l >= 0 && r <= s.size() - 1 && s[l] == s[r]) l--, r++;\n            if (res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#z字形变换",
    "href": "posts/leetcode_1-10/index.html#z字形变换",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "6. Z字形变换",
    "text": "6. Z字形变换\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        string res;\n        if (numRows == 1) return s;\n\n        for (int i = 0; i < numRows; i++) {\n            if (i == 0 || i == numRows - 1) {\n                for (int j = i; j < s.size(); j += 2 * numRows - 2) {\n                    res += s[j];\n                }\n            } else {\n                for (int j = i, k = 2 * numRows - 2 - i; j < s.size() || k < s.size(); j += 2 * numRows - 2, k += 2 * numRows - 2) {\n                    if (j < s.size()) res += s[j];\n                    if (k < s.size()) res += s[k];\n                }\n            }\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#整数反转",
    "href": "posts/leetcode_1-10/index.html#整数反转",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "7. 整数反转",
    "text": "7. 整数反转\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int r = 0;\n        while (x) {\n            if (r > 0 && r > (INT_MAX - x % 10) / 10) return 0;\n            if (r < 0 && r < (INT_MIN - x % 10) / 10) return 0;\n            r = r * 10 + x % 10;\n            x /= 10;\n        }\n        return r; \n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#字符串转换整数-atoi",
    "href": "posts/leetcode_1-10/index.html#字符串转换整数-atoi",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "8. 字符串转换整数 (atoi)",
    "text": "8. 字符串转换整数 (atoi)\n请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。\n函数 myAtoi(string s) 的算法如下：\n读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -> 123， “0032” -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意：\n本题中的空白字符只包括空格字符 ’ ’ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。\n#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int k = 0;\n        while (k < s.size()) {\n            if (s[k] == ' ') k++;\n            else break;\n        }\n        if (k == s.size()) return 0; \n\n        int minus = 1;\n        if (s[k] == '-') minus = -1, k++;\n        else if (s[k] == '+') k++;\n\n        int res = 0;\n        while (k < s.size() && s[k] >= '0' && s[k] <= '9') {\n            int x = s[k] - '0';\n            if (minus == 1 && res > (INT_MAX - x) / 10) return INT_MAX;\n            else if (minus == -1 && -res < (INT_MIN + x) / 10) return INT_MIN;\n            else if (minus == -1 && -res * 10 - x == INT_MIN) return INT_MIN; // different from above\n            res = res * 10 + x;\n            k++;\n        }\n        return res * minus;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#回文数",
    "href": "posts/leetcode_1-10/index.html#回文数",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "9. 回文数",
    "text": "9. 回文数\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return 0;\n\n        int y = x;\n        long long res = 0;\n        while (x) {\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        return res == y;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_1-10/index.html#正则表达式匹配",
    "href": "posts/leetcode_1-10/index.html#正则表达式匹配",
    "title": "LeetCode 刷题记录 1 - 10",
    "section": "10. 正则表达式匹配",
    "text": "10. 正则表达式匹配\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ’*’ 的正则表达式匹配。\n‘.’ 匹配任意单个字符 ’*’ 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.size(), m = p.size();\n        s = ' ' + s, p = ' ' + p;\n        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));\n        f[0][0] = true;\n\n        for (int i = 0; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (j + 1 <= m && p[j + 1] == '*') continue;\n                else if (i && p[j] != '*') {\n                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');\n                } else if (p[j] == '*') {\n                    f[i][j] = f[i][j - 2] || i && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.');\n                }\n            }\n        }\n        return f[n][m];\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html",
    "href": "posts/leetcode_11-20/index.html",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "",
    "text": "给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int res = 0;\n        for (int i = 0, j = height.size() - 1; i < j;) {\n            res = max(res, min(height[i], height[j]) * (j - i));\n            if (height[i] > height[j]) j--;\n            else i++;\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#整数转罗马数字",
    "href": "posts/leetcode_11-20/index.html#整数转罗马数字",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "12. 整数转罗马数字",
    "text": "12. 整数转罗马数字\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        int values[] = {\n            1000,\n            900, 500, 400, 100,\n            90, 50, 40, 10,\n            9, 5, 4, 1\n        };\n\n        string reps[] = {\n           \"M\", \n           \"CM\", \"D\", \"CD\", \"C\",\n           \"XC\", \"L\", \"XL\", \"X\",\n           \"IX\", \"V\", \"IV\", \"I\"\n        };\n        \n        string res = \"\";\n        for (int i = 0; i < 13; i++) {\n            while (num >= values[i]) {\n                num -= values[i];\n                res += reps[i];\n            }\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#罗马数字转整数",
    "href": "posts/leetcode_11-20/index.html#罗马数字转整数",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "13. 罗马数字转整数",
    "text": "13. 罗马数字转整数\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> hash;\n        int res = 0;\n        hash['I'] = 1, hash['V'] = 5;\n        hash['X'] = 10, hash['L'] = 50;\n        hash['C'] = 100, hash['D'] = 500;\n        hash['M'] = 1000;\n\n        for (int i = 0; i < s.size(); i++) {\n            if (i + 1 < s.size() && hash[s[i]] < hash[s[i + 1]]) {\n                res -= hash[s[i]];\n            } else {\n                res += hash[s[i]];\n            }\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#最长公共前缀",
    "href": "posts/leetcode_11-20/index.html#最长公共前缀",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "14. 最长公共前缀",
    "text": "14. 最长公共前缀\n编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 ““。\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        if (strs.empty()) return res;\n\n        for (int i = 0;; i++) {\n            char c = strs[0][i];\n            for (auto &str : strs) {\n                if (i >= str.size() || c != str[i]) {\n                    return res;\n                }\n            }\n            res += c;\n        }\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#三数之和",
    "href": "posts/leetcode_11-20/index.html#三数之和",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "15. 三数之和",
    "text": "15. 三数之和\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> res;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i++) {\n            if (i && nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1, k = nums.size() - 1; j < k; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n                while (j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= 0) k--;\n                if (nums[i] + nums[j] + nums[k] == 0) {\n                    res.push_back({nums[i], nums[j], nums[k]});\n                }\n            }\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#最接近的三数之和",
    "href": "posts/leetcode_11-20/index.html#最接近的三数之和",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "16. 最接近的三数之和",
    "text": "16. 最接近的三数之和\n给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n返回这三个数的和。\n假定每组输入只存在恰好一个解。\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        pair<int, int> res(INT_MAX, INT_MAX);\n        for (int i = 0; i < nums.size(); i++) {\n            if (i && nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1, k = nums.size() - 1; j < k; j++) {\n                while (j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= target) k--;\n                int s = nums[i] + nums[j] + nums[k];\n                res = min(res, make_pair(abs(s - target), s));\n                if (j < k - 1) {\n                    s = nums[i] + nums[j] + nums[k - 1];\n                    res = min(res, make_pair(target - s, s));\n                }\n            }\n        }\n        return res.second;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#电话号码的字母组合",
    "href": "posts/leetcode_11-20/index.html#电话号码的字母组合",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "17. 电话号码的字母组合",
    "text": "17. 电话号码的字母组合\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> res;\n    string ref[10] = {\n        \"\", \"\", \"abc\", \"def\",\n        \"ghi\", \"jkl\", \"mno\",\n        \"pqrs\", \"tuv\", \"wxyz\"\n    };\n\n    vector<string> letterCombinations(string digits) {\n        if (digits.empty()) return res;\n        dfs(digits, 0, \"\");\n        return res;\n    }\n\n    void dfs(string& digits, int len, string path) {\n        if (len == digits.size()) res.push_back(path);\n        else {\n            for (auto& c : ref[digits[len] - '0']) {\n                dfs(digits, len + 1, path + c);\n            }\n        }\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#四数之和",
    "href": "posts/leetcode_11-20/index.html#四数之和",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "18. 四数之和",
    "text": "18. 四数之和\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n0 <= a, b, c, d < n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int l = nums.size();\n        vector<vector<int>> res;\n        for (int i = 0; i < l; i++) {\n            if (i && nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1; j < l; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n                for (int k = j + 1, u = l - 1; k < u; k++) {\n                    if (k > j + 1 && nums[k] == nums[k - 1]) continue;\n                    while (u - 1 > k && nums[i] + nums[j] + nums[k] + nums[u - 1] >= target) u--;\n                    if (nums[i] + nums[j] + nums[k] + nums[u] == target) {\n                        res.push_back({nums[i], nums[j], nums[k], nums[u]});\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#删除链表的倒数第-n-个结点",
    "href": "posts/leetcode_11-20/index.html#删除链表的倒数第-n-个结点",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "19. 删除链表的倒数第 N 个结点",
    "text": "19. 删除链表的倒数第 N 个结点\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n        \n        int k = 0;\n        for (auto p = dummy; p; p = p->next) k++;\n\n        auto p = dummy;\n        for (int i = 0; i < k - n - 1; i++) p = p->next;\n        p->next = p->next->next;\n\n        return dummy->next; \n    }\n};"
  },
  {
    "objectID": "posts/leetcode_11-20/index.html#有效的括号",
    "href": "posts/leetcode_11-20/index.html#有效的括号",
    "title": "LeetCode 刷题记录 11 - 20",
    "section": "20. 有效的括号",
    "text": "20. 有效的括号\n给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，’]’ 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号.\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> stk;\n\n        for (auto& c : s) {\n            if (c == '(' || c == '{' || c == '[') stk.push(c);\n            else {\n                if (!stk.empty() && abs(c - stk.top()) <= 2) stk.pop();\n                else return false;\n            }\n        }\n        return stk.empty();\n    }\n};"
  },
  {
    "objectID": "posts/league_of_legends_s12/index.html",
    "href": "posts/league_of_legends_s12/index.html",
    "title": "DRX夺冠有感",
    "section": "",
    "text": "关于最后总决赛，我不知道为什么大部分人都希望SKT夺冠，希望Faker重回巅峰，偏偏我希望DRX夺冠，因为我昨天看比赛时候的心情和2017年S7一样, 就像我在第一篇博客里讲的：\n\n“所以我觉得我的2017年过的并不失败，大概我心中住了一个Ambition吧.”\n\n\n\n他和Faker同为麻浦高中的学生，同一年打职业，却在十年里辗转了七支队伍，未曾夺得一冠。\nDeft曾经也在EDG打过，正好那天的解说席上明凯也在，不知道同为追梦人，也同是队友，他心里是什么想法。\n或许他已经释然了，一辈子拿不到冠军其实才是常态，至少努力过就没什么遗憾了。\n赛后采访时Deft的一段话我觉得值得记录下来：\n\n“我唯一擅长的只有英雄联盟，如果我不能在我最擅长的事情上取得成功，那我根本不知道我的人生还有什么意义。”"
  },
  {
    "objectID": "posts/leetcode_weekly_competition/index.html",
    "href": "posts/leetcode_weekly_competition/index.html",
    "title": "LeetCode 周赛记录",
    "section": "",
    "text": "给你一个下标从 0 开始的字符串数组 words 。\n如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。\n例如，“abca” 和 “cba” 相似，因为它们都由字符 ‘a’、‘b’、‘c’ 组成。 然而，“abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。 请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 <= i < j <= word.length - 1 。\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int similarPairs(vector<string>& words) {\n        int n = words.size();\n        int ans = 0;\n        unordered_map<string, int> mp;\n        for (int i = 0; i < n; i++) {\n            string s = words[i];\n            sort(s.begin(), s.end());\n            s.erase(unique(s.begin(), s.end()), s.end());\n            ans += mp[s];\n            mp[s]++;\n        }\n        return ans;\n    }\n};\n\n\n\n给你一个正整数 n 。\n请你将 n 的值替换为 n 的 质因数 之和，重复这一过程。\n注意，如果 n 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。 返回 n 可以取到的最小值。\n#include <iostream>     \n#include <algorithm>    \n\nusing namespace std;\n\nclass Solution {\npublic:\n    // you need to prove that it is a monotonically decreasing function.\n    int work(int n) {\n        int res = 0;\n\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i == 0) n /= i, res += i;\n            }\n        }\n        if (n > 1) res += n;\n        return res;\n    }\n\n    int smallestValue(int n) {\n        while (true) {\n            int next = work(n);\n            if (next == n) break;\n            n = next;\n        }\n        return n;\n    }\n};"
  },
  {
    "objectID": "posts/leetcode_weekly_competition/index.html#第327场周赛",
    "href": "posts/leetcode_weekly_competition/index.html#第327场周赛",
    "title": "LeetCode 周赛记录",
    "section": "第327场周赛",
    "text": "第327场周赛\n\n1. 正整数和负整数的最大计数\n给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。\n换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。 注意：0 既不是正整数也不是负整数。\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumCount(vector<int>& nums) {\n        int neg = 0;\n        int pos = 0;\n\n        for (auto& num : nums) {\n            if (num < 0) {\n                neg++;\n            } else if (num > 0) {\n                pos++;\n            }\n        }\n\n        return max(neg, pos);\n    }\n};\n\n\n2. 执行 K 次操作后的最大分数\n给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。\n在一步 操作 中：\n选出一个满足 0 <= i < nums.length 的下标 i ， 将你的 分数 增加 nums[i] ，并且 将 nums[i] 替换为 ceil(nums[i] / 3) 。 返回在 恰好 执行 k 次操作后，你可能获得的最大分数。\n向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        priority_queue<int> heap;\n        for (auto& num : nums) {\n            heap.push(num);\n        }\n        long long sum = 0;\n        for (int i = 0; i < k; i++) {\n            int max = heap.top();\n            sum += max;\n            heap.pop();\n            heap.push((max + 2) / 3); // don't use ceil() here;\n        }\n        return sum;\n    }\n};"
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archive",
    "section": "",
    "text": "LeetCode 刷题记录 21 - 30\n\n\n\n\n\n\n\n\n\nJan 7, 2023\n\n\n\n\n\n\n\n\n2022年观影记录\n\n\n\n\n\n\n\n\n\nJan 7, 2023\n\n\n\n\n\n\n\n\nLeetCode 刷题记录 11 - 20\n\n\n\n\n\n\n\n\n\nJan 6, 2023\n\n\n\n\n\n\n\n\n<克拉拉与太阳>读后感\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n\n\n\n\n\n\nLeetCode 周赛记录\n\n\n\n\n\n\n\n\n\nDec 18, 2022\n\n\n\n\n\n\n\n\nLeetCode 刷题记录 1 - 10\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\n\n\n\n\n\n\nDRX夺冠有感\n\n\n\n\n\n\n\n\n\nNov 7, 2022\n\n\n\n\n\n\n\n\n基础算法模板\n\n\n\n\n\n\n\n\n\nNov 5, 2022\n\n\n\n\n\n\n\n\nCMU 15-213 Lab0\n\n\n\n\n\n\n\n\n\nOct 11, 2022\n\n\n\n\n\n\n\n\n实现一个简易的C++ String类\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n\n\n\n\n\n\n实现一个简易Shell\n\n\n\n\n\n\n\n\n\nSep 12, 2022\n\n\n\n\n\n\n\n\n这几年\n\n\n\n\n\n\n\n\n\nJul 4, 2022\n\n\n\n\n\n\nNo matching items"
  }
]